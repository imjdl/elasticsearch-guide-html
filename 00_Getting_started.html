<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.2">
<title>placeholder0</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
<h1>placeholder0</h1>
</div>
<div id="content">
<h1 id="getting-started" class="sect0">基础入门</h1>

<div class="sect1">
<h2 id="intro">你知道的, 为了搜索&#8230;&#8203;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 <a href="https://lucene.apache.org/core/">Apache Lucene&#8482;</a> 基础之上。
 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库&#8212;&#8203;无论是开源还是私有。</p>
</div>
<div class="paragraph">
<p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。
更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene <em>非常</em> 复杂。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单，
通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
</div>
<div class="paragraph">
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。
它可以被下面这样准确的形容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个分布式的实时文档存储，<em>每个字段</em> 可以被索引与搜索</p>
</li>
<li>
<p>一个分布式实时分析搜索引擎</p>
</li>
<li>
<p>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信，
可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）。</p>
</div>
<div class="paragraph">
<p>就 Elasticsearch 而言，起步很简单。对于初学者来说，它预设了一些适当的默认值，并隐藏了复杂的搜索理论知识。
它 <em>开箱即用</em> 。只需最少的理解，你很快就能具有生产力。</p>
</div>
<div class="paragraph">
<p>随着你知识的积累，你可以利用 Elasticsearch 更多的高级特性，它的整个引擎是可配置并且灵活的。
从众多高级特性中，挑选恰当去修饰的 Elasticsearch，使它能解决你本地遇到的问题。</p>
</div>
<div class="paragraph">
<p>你可以免费下载，使用，修改 Elasticsearch。它在 <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache 2 license</a> 协议下发布的，
这是众多灵活的开源协议之一。Elasticsearch 的源码被托管在 Github 上 <a href="https://github.com/elastic/elasticsearch">github.com/elastic/elasticsearch</a>。
如果你想加入我们这个令人惊奇的 contributors 社区，看这里 <a href="https://github.com/elastic/elasticsearch/blob/master/CONTRIBUTING.md">Contributing to Elasticsearch</a>。</p>
</div>
<div class="paragraph">
<p>如果你对 Elasticsearch 有任何相关的问题，包括特定的特性(specific features)、语言客户端(language clients)、插件(plugins)，可以在这里 <a href="https://discuss.elastic.co">discuss.elastic.co</a> 加入讨论。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">回忆时光</div>
<div class="paragraph">
<p>许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。
在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。</p>
</div>
<div class="paragraph">
<p>直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。
他发布了他的第一个开源项目 Compass。</p>
</div>
<div class="paragraph">
<p>后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出，
他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。</p>
</div>
<div class="paragraph">
<p>第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。
一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。</p>
</div>
<div class="paragraph">
<p>据说，Shay 的妻子还在等着她的食谱搜索引擎&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-elasticsearch">安装并运行 Elasticsearch</h3>
<div class="paragraph">
<p>想用最简单的方式去理解 Elasticsearch 能为你做什么，那就是使用它了，让我们开始吧！ </p>
</div>
<div class="paragraph">
<p>安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java，最好的选择是，你可以从 <a href="http://www.java.com"><em>www.java.com</em></a> 获得官方提供的最新版本的 Java。</p>
</div>
<div class="paragraph">
<p>之后，你可以从 elastic 的官网 <a href="https://www.elastic.co/downloads/elasticsearch"><em>elastic.co/downloads/elasticsearch</em></a>
获取最新版本的 Elasticsearch。</p>
</div>
<div class="paragraph">
<p>要想安装 Elasticsearch，先下载并解压适合你操作系统的 Elasticsearch 版本。如果你想了解更多的信息，
可以查看 Elasticsearch 参考手册里边的安装部分，这边给出的链接指向安装说明 {ref}/_installation.html[Installation]。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>当你准备在生产环境安装 Elasticsearch 时，你可以在 <a href="http://www.elastic.co/downloads/elasticsearch">官网下载地址</a> 找
到 Debian 或者 RPM 包，除此之外，你也可以使用官方支持的 <a href="https://github.com/elasticsearch/puppet-elasticsearch">Puppet module</a> 或者 <a href="https://github.com/elasticsearch/cookbook-elasticsearch">Chef cookbook</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当你解压好了归档文件之后，Elasticsearch 已经准备好运行了。按照下面的操作，在前台(foregroud)启动 Elasticsearch：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">cd elasticsearch-&lt;version&gt;
./bin/elasticsearch <b class="conum">(1)</b> <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 <code>-d</code> 。</p>
</li>
<li>
<p>如果你是在 Windows 上面运行 Elasticseach，你应该运行 <code>bin\elasticsearch.bat</code> 而不是 <code>bin\elasticsearch</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">curl 'http://localhost:9200/?pretty'</code></pre>
</div>
</div>
<div class="paragraph">
<p>TIP：如果你是在 Windows 上面运行 Elasticsearch，你可以从 <a href="http://curl.haxx.se/download.html"><code>http://curl.haxx.se/download.html</code></a> 中下载 cURL。
cURL 给你提供了一种将请求提交到 Elasticsearch 的便捷方式，并且安装 cURL 之后，你可以通过复制与粘贴去尝试书中的许多例子。</p>
</div>
<div class="paragraph">
<p>你应该得到和下面类似的响应(response)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "name" : "Tom Foster",
  "cluster_name" : "elasticsearch",
  "version" : {
    "number" : "2.1.0",
    "build_hash" : "72cd1f1a3eee09505e036106146dc1949dc5dc87",
    "build_timestamp" : "2015-11-18T22:40:03Z",
    "build_snapshot" : false,
    "lucene_version" : "5.3.1"
  },
  "tagline" : "You Know, for Search"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就意味着你现在已经启动并运行一个 Elasticsearch 节点了，你可以用它做实验了。
单个 <em>节点</em> 可以作为一个运行中的 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 <code>cluster.name</code> 的节点，
他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 <code>elasticsearch.yml</code> 配置文件中
修改 <code>cluster.name</code> ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。
关于上面的 <code>cluster.name</code> 以及其它  <a href="#important-configuration-changes">Important Configuration Changes</a> 信息，
你可以在这本书后面提供的生产部署章节找到更多。</p>
</div>
<div class="paragraph">
<p>TIP：看到下方的 View in Sense 的例子了么？<a href="#sense">Install the Sense console</a> 使用你自己的 Elasticsearch 集群去运行这本书中的例子，
查看会有怎样的结果。</p>
</div>
<div class="paragraph">
<p>当 Elastcisearch 在前台运行时，你可以通过按 Ctrl+C 去停止。</p>
</div>
<div class="sect3">
<h4 id="sense">安装 Sense</h4>
<div class="paragraph">
<p>Sense 是一个 <a href="https://www.elastic.co/guide/en/kibana/4.6/index.html">Kibana</a> 应用 
它提供交互式的控制台，通过你的浏览器直接向 Elasticsearch 提交请求。
这本书的在线版本包含有一个 View in Sense 的链接，里面有许多代码示例。当点击的时候，它会打开一个代码示例的Sense控制台。
你不必安装 Sense，但是它允许你在本地的 Elasticsearch 集群上测试示例代码，从而使本书更具有交互性。</p>
</div>
<div class="paragraph">
<p> 安装与运行 Sense：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在 Kibana 目录下运行下面的命令，下载并安装 Sense app：</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">./bin/kibana plugin --install elastic/sense <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Windows上面执行: <code>bin\kibana.bat plugin --install elastic/sense</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>NOTE：你可以直接从这里 <a href="https://download.elastic.co/elastic/sense/sense-latest.tar.gz" class="bare">https://download.elastic.co/elastic/sense/sense-latest.tar.gz</a> 下载 Sense
离线安装可以查看这里 <a href="https://www.elastic.co/guide/en/sense/current/installing.html#manual_download">install it on an offline machine</a> 。</p>
</div>
</li>
<li>
<p>启动 Kibana.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">./bin/kibana <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Windows 上启动 kibana: <code>bin\kibana.bat</code> 。</p>
</li>
</ol>
</div>
</li>
<li>
<p>在你的浏览器中打开 Sense: <code><a href="http://localhost:5601/app/sense" class="bare">http://localhost:5601/app/sense</a></code> 。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_talking_to_elasticsearch">和 Elasticsearch 交互</h3>
<div class="paragraph">
<p>和 Elasticsearch 的交互方式取决于你是否使用 Java</p>
</div>
<div class="sect3">
<h4 id="_java_api">Java API</h4>
<div class="paragraph">
<p>如果你正在使用 Java，在代码中你可以使用 Elasticsearch 内置的两个客户端：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">节点客户端（Node client）</dt>
<dd>
<p>节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。</p>
</dd>
<dt class="hdlist1">传输客户端（Transport client）</dt>
<dd>
<p>轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>两个 Java 客户端都是通过 <em>9300</em> 端口并使用 Elasticsearch 的原生 <em>传输</em> 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>Java 客户端作为节点必须和 Elasticsearch 有相同的 <em>主要</em> 版本；否则，它们之间将无法互相理解。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>更多的 Java 客户端信息可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch Clients</a> 中找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_restful_api_with_json_over_http">RESTful API with JSON over HTTP</h4>
<div class="paragraph">
<p>所有其他语言可以使用 RESTful API 通过端口 <em>9200</em> 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 <code>curl</code> 命令来和 Elasticsearch 交互。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Elasticsearch 为以下语言提供了官方客户端--Groovy、JavaScript、.NET、 PHP、 Perl、 Python 和 Ruby&#8212;&#8203;还有很多社区提供的客户端和插件，所有这些都可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch Clients</a> 中找到。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>被 <code>&lt; &gt;</code> 标记的部件：</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>VERB</code>
</td>
<td class="hdlist2">
<p>适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>PROTOCOL</code>
</td>
<td class="hdlist2">
<p><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>HOST</code>
</td>
<td class="hdlist2">
<p>Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>PORT</code>
</td>
<td class="hdlist2">
<p>运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>PATH</code>
</td>
<td class="hdlist2">
<p>API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>QUERY_STRING</code>
</td>
<td class="hdlist2">
<p>任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>BODY</code>
</td>
<td class="hdlist2">
<p>一个 JSON 格式的请求体 (如果请求需要的话)</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，计算集群中文档的数量，我们可以用这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -XGET 'http://localhost:9200/_count?pretty' -d '
{
    "query": {
        "match_all": {}
    }
}
'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch 返回一个 HTTP 状态码（例如：<code>200 OK</code>）和（除`HEAD`请求）一个 JSON 格式的返回值。前面的 <code>curl</code> 请求将返回一个像下面一样的 JSON 体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "count" : 0,
    "_shards" : {
        "total" : 5,
        "successful" : 5,
        "failed" : 0
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在返回结果中没有看到 HTTP 头信息是因为我们没有要求`curl`显示它们。想要看到头信息，需要结合 <code>-i</code> 参数来使用 <code>curl</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -i -XGET 'localhost:9200/'</code></pre>
</div>
</div>
<div class="paragraph">
<p>在书中剩余的部分，我们将用缩写格式来展示这些 <code>curl</code> 示例，所谓的缩写格式就是省略请求中所有相同的部分，例如主机名、端口号以及 <code>curl</code> 命令本身。而不是像下面显示的那样用一个完整的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -XGET 'localhost:9200/_count?pretty' -d '
{
    "query": {
        "match_all": {}
    }
}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将用缩写格式显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_count
{
    "query": {
        "match_all": {}
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上， <a href="#sense">Sense 控制台</a> 也使用这样相同的格式。如果你正在阅读这本书的在线版本,可以通过点击 Sense 链接视图在 Sense 上打开和运行示例代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_document_oriented">面向文档</h3>
<div class="paragraph">
<p>在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。</p>
</div>
<div class="paragraph">
<p>也许有一天你想把这些对象存储在数据库中。使用关系型数据库的行和列存储，这相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构&#8212;&#8203;通常一个字段&gt;对应一列&#8212;&#8203;而且又不得不在每次查询时重新构造对象。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 是 <em>面向文档</em> 的，意味着它存储整个对象或 <em>文档</em>。Elasticsearch 不仅存储文档，而且 <em>索引</em> 每个文档的内容使之可以被检索。在 Elasticsearch 中，你
对文档进行索引、检索、排序和过滤&#8212;&#8203;而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
</div>
<div class="sect3">
<h4 id="_json">JSON</h4>
<div class="paragraph">
<p>Elasticsearch 使用 JavaScript Object Notation 或者 <a href="http://en.wikipedia.org/wiki/Json"><em>JSON</em></a> 作为文档的序列化格式。JSON 序列化被大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。
它简单、简洁、易于阅读。</p>
</div>
<div class="paragraph">
<p>考虑一下这个 JSON 文档，它代表了一个 user 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "email":      "john@smith.com",
    "first_name": "John",
    "last_name":  "Smith",
    "info": {
        "bio":         "Eco-warrior and defender of the weak",
        "age":         25,
        "interests": [ "dolphins", "whales" ]
    },
    "join_date": "2014/05/01"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然原始的 <code>user</code> 对象很复杂，但这个对象的结构和含义在 JSON 版本中都得到了体现和保留。在 Elasticsearch 中将对象转化为 JSON 并做索引要比在一个扁平的表结构中做相同的事情简单的多。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>几乎所有的语言都有相应的模块可以将任意的数据结构或对象转化成 JSON 格式，只是细节各不相同。具体请查看 <em>serialization</em> 或者 <em>marshalling</em> 这两个
处理 JSON 的模块。官方 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch 客户端</a> 自动为您提供 JSON 转化。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finding_your_feet">适应新环境</h3>
<div class="paragraph">
<p>为了对 Elasticsearch 能实现什么及其上手容易程度有一个基本印象，让我们从一个简单的教程开始并介绍索引、搜索及聚合等基础概念。</p>
</div>
<div class="paragraph">
<p>我们将一并介绍一些新的技术术语和基础概念，因此即使无法立即全盘理解也无妨。在本书后续内容中，我们将深入介绍这里提到的所有概念。</p>
</div>
<div class="paragraph">
<p>接下来尽情享受 Elasticsearch 探索之旅。</p>
</div>
<div class="sect3">
<h4 id="_创建一个雇员目录">创建一个雇员目录</h4>
<div class="paragraph">
<p>我们受雇于  <em>Megacorp</em> 公司，作为 HR 部门新的 <em>“热爱无人机”</em> （<em>"We love our
drones!"</em>）激励项目的一部分，我们的任务是为此创建一个雇员目录。该目录应当能培养雇员认同感及支持实时、高效、动态协作，因此有一些业务需求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>支持包含多值标签、数值、以及全文本的数据</p>
</li>
<li>
<p>检索任一雇员的完整信息</p>
</li>
<li>
<p>允许结构化搜索，比如查询 30 岁以上的员工</p>
</li>
<li>
<p>允许简单的全文搜索以及较复杂的短语搜索</p>
</li>
<li>
<p>支持在匹配文档内容中高亮显示搜索片段</p>
</li>
<li>
<p>支持基于数据创建和管理分析仪表盘</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indexing_employee_documents">索引雇员文档</h3>
<div class="paragraph">
<p>第一个业务需求就是存储雇员数据。 这将会以 <em>雇员文档</em> 的形式存储：一个文档代表一个雇员。存储数据到 Elasticsearch 的行为叫做 <em>索引</em> ，但在索引一个文档之前，需要确定将文档存储在哪里。</p>
</div>
<div class="paragraph">
<p>一个 Elasticsearch 集群可以  包含多个 <em>索引</em> ，相应的每个索引可以包含多个 <em>类型</em> 。 这些不同的类型存储着多个 <em>文档</em> ，每个文档又有  多个 <em>属性</em> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Index Versus Index Versus Index</div>
<div class="paragraph">
<p>你也许已经注意到 <em>索引</em> 这个词在 Elasticsearch 语境中包含多重意思，  所以有必要做一点儿说明：</p>
</div>
<div class="paragraph">
<p>索引（名词）：</p>
</div>
<div class="paragraph">
<p>如前所述，一个 <em>索引</em> 类似于传统关系数据库中的一个 <em>数据库</em> ，是一个存储关系型文档的地方。 <em>索引</em> (<em>index</em>) 的复数词为 <em>indices</em> 或 <em>indexes</em> 。</p>
</div>
<div class="paragraph">
<p>索引（动词）：</p>
</div>
<div class="paragraph">
<p><em>索引一个文档</em> 就是存储一个文档到一个 <em>索引</em> （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 <code>INSERT</code> 关键词，除了文档已存在时新文档会替换旧文档情况之外。</p>
</div>
<div class="paragraph">
<p>倒排索引：</p>
</div>
<div class="paragraph">
<p>关系型数据库通过增加一个 <em>索引</em> 比如一个 B树（B-tree）索引  到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做  <em>倒排索引</em> 的结构来达到相同的目的。</p>
</div>
<div class="paragraph">
<p>+
默认的，一个文档中的每一个属性都是 <em>被索引</em> 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。我们将在 <a href="#inverted-index">倒排索引</a> 讨论倒排索引的更多细节。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>对于雇员目录，我们将做如下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个雇员索引一个文档，包含该雇员的所有信息。</p>
</li>
<li>
<p>每个文档都将是 <code>employee</code> <em>类型</em> 。</p>
</li>
<li>
<p>该类型位于 <em>索引</em> <code>megacorp</code> 内。</p>
</li>
<li>
<p>该索引保存在我们的 Elasticsearch 集群中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实践中这非常简单（尽管看起来有很多步骤），我们可以通过一条命令完成所有这些动作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /megacorp/employee/1
{
    "first_name" : "John",
    "last_name" :  "Smith",
    "age" :        25,
    "about" :      "I love to go rock climbing",
    "interests": [ "sports", "music" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，路径 <code>/megacorp/employee/1</code> 包含了三部分的信息：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">megacorp</dt>
<dd>
<p>索引名称</p>
</dd>
<dt class="hdlist1">employee</dt>
<dd>
<p>类型名称</p>
</dd>
<dt class="hdlist1">1</dt>
<dd>
<p>特定雇员的ID</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。</p>
</div>
<div class="paragraph">
<p>很简单！无需进行执行管理任务，如创建一个索引或指定每个属性的数据类型之类的，可以直接只索引一个文档。Elasticsearch 默认地完成其他一切，因此所有必需的管理任务都在后台使用默认设置完成。</p>
</div>
<div class="paragraph">
<p>进行下一步前，让我们增加更多的员工信息到目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /megacorp/employee/2
{
    "first_name" :  "Jane",
    "last_name" :   "Smith",
    "age" :         32,
    "about" :       "I like to collect rock albums",
    "interests":  [ "music" ]
}

PUT /megacorp/employee/3
{
    "first_name" :  "Douglas",
    "last_name" :   "Fir",
    "age" :         35,
    "about":        "I like to build cabinets",
    "interests":  [ "forestry" ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_a_document">检索文档</h3>
<div class="paragraph">
<p>目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。</p>
</div>
<div class="paragraph">
<p>这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回结果包含了文档的一些元数据，以及 <code>_source</code> 属性，内容是 John Smith 雇员的原始 JSON 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "megacorp",
  "_type" :    "employee",
  "_id" :      "1",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "first_name" :  "John",
      "last_name" :   "Smith",
      "age" :         25,
      "about" :       "I love to go rock climbing",
      "interests":  [ "sports", "music" ]
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>将 HTTP 命令由 <code>PUT</code> 改为 <code>GET</code> 可以用来检索文档，同样的，可以使用 <code>DELETE</code> 命令来删除文档，以及使用 <code>HEAD</code> 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 <code>PUT</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_search_lite">轻量搜索</h3>
<div class="paragraph">
<p>一个 <code>GET</code> 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！</p>
</div>
<div class="paragraph">
<p>第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以看到，我们仍然使用索引库 <code>megacorp</code> 以及类型 <code>employee</code>，但与指定一个文档 ID 不同，这次使用 <code>_search</code> 。返回结果包括了所有三个文档，放在数组 <code>hits</code> 中。一个搜索默认返回十条结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "took":      6,
   "timed_out": false,
   "_shards": { ... },
   "hits": {
      "total":      3,
      "max_score":  1,
      "hits": [
         {
            "_index":         "megacorp",
            "_type":          "employee",
            "_id":            "3",
            "_score":         1,
            "_source": {
               "first_name":  "Douglas",
               "last_name":   "Fir",
               "age":         35,
               "about":       "I like to build cabinets",
               "interests": [ "forestry" ]
            }
         },
         {
            "_index":         "megacorp",
            "_type":          "employee",
            "_id":            "1",
            "_score":         1,
            "_source": {
               "first_name":  "John",
               "last_name":   "Smith",
               "age":         25,
               "about":       "I love to go rock climbing",
               "interests": [ "sports", "music" ]
            }
         },
         {
            "_index":         "megacorp",
            "_type":          "employee",
            "_id":            "2",
            "_score":         1,
            "_source": {
               "first_name":  "Jane",
               "last_name":   "Smith",
               "age":         32,
               "about":       "I like to collect rock albums",
               "interests": [ "music" ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。</p>
</div>
<div class="paragraph">
<p>接下来，尝试下搜索姓氏为 <code>Smith</code> 的雇员。为此，我们将使用一个 <em>高亮</em> 搜索，很容易通过命令行完成。这个方法一般涉及到一个 <em>查询字符串</em> （<em>query-string</em>） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search?q=last_name:Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们仍然在请求路径中使用 <code>_search</code> 端点，并将查询本身赋值给参数 <code>q=</code> 。返回结果给出了所有的 Smith：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": {
      "total":      2,
      "max_score":  0.30685282,
      "hits": [
         {
            ...
            "_source": {
               "first_name":  "John",
               "last_name":   "Smith",
               "age":         25,
               "about":       "I love to go rock climbing",
               "interests": [ "sports", "music" ]
            }
         },
         {
            ...
            "_source": {
               "first_name":  "Jane",
               "last_name":   "Smith",
               "age":         32,
               "about":       "I like to collect rock albums",
               "interests": [ "music" ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_search_with_query_dsl">使用查询表达式搜索</h3>
<div class="paragraph">
<p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索  ，但它有自身的局限性（参见 <a href="#search-lite"><em>轻量</em> 搜索</a> ）。Elasticsearch 提供一个丰富灵活的查询语言叫做 <em>查询表达式</em> ， 它支持构建更加复杂和健壮的查询。</p>
</div>
<div class="paragraph">
<p><em>领域特定语言</em> （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "query" : {
        "match" : {
            "last_name" : "Smith"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 <em>query-string</em> 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 <code>match</code> 查询（属于查询类型之一，后续将会了解）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_complicated_searches">更复杂的搜索</h3>
<div class="paragraph">
<p>现在尝试下更复杂的搜索。 同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。查询需要稍作调整，使用过滤器 <em>filter</em> ，它支持高效地执行一个结构化查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "query" : {
        "bool": {
            "must": {
                "match" : {
                    "last_name" : "smith" <b class="conum">(1)</b>
                }
            },
            "filter": {
                "range" : {
                    "age" : { "gt" : 30 } <b class="conum">(2)</b>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这部分与我们之前使用的  <code>match</code> <em>查询</em> 一样。</p>
</li>
<li>
<p>这部分是一个 <code>range</code> <em>过滤器</em> ， 它能找到年龄大于 30 的文档，其中 <code>gt</code> 表示_大于_(<em>great than</em>)。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>目前无需太多担心语法问题，后续会更详细地介绍。只需明确我们添加了一个 <em>过滤器</em> 用于执行一个范围查询，并复用之前的 <code>match</code> 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": {
      "total":      1,
      "max_score":  0.30685282,
      "hits": [
         {
            ...
            "_source": {
               "first_name":  "Jane",
               "last_name":   "Smith",
               "age":         32,
               "about":       "I like to collect rock albums",
               "interests": [ "music" ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_full_text_search">全文搜索</h3>
<div class="paragraph">
<p>截止目前的搜索相对都很简单：单个姓名，通过年龄过滤。现在尝试下稍微高级点儿的全文搜索——一项 传统数据库确实很难搞定的任务。</p>
</div>
<div class="paragraph">
<p>搜索下所有喜欢攀岩（rock climbing）的雇员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "query" : {
        "match" : {
            "about" : "rock climbing"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>显然我们依旧使用之前的 <code>match</code> 查询在`about` 属性上搜索 ``rock climbing'' 。得到两个匹配的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": {
      "total":      2,
      "max_score":  0.16273327,
      "hits": [
         {
            ...
            "_score":         0.16273327, <b class="conum">(1)</b>
            "_source": {
               "first_name":  "John",
               "last_name":   "Smith",
               "age":         25,
               "about":       "I love to go rock climbing",
               "interests": [ "sports", "music" ]
            }
         },
         {
            ...
            "_score":         0.016878016, <b class="conum">(1)</b>
            "_source": {
               "first_name":  "Jane",
               "last_name":   "Smith",
               "age":         32,
               "about":       "I like to collect rock albums",
               "interests": [ "music" ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>相关性得分</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Elasticsearch  默认按照相关性得分排序，即每个文档跟查询的匹配程度。第一个最高得分的结果很明显：John Smith 的 <code>about</code> 属性清楚地写着 ``rock
climbing'' 。</p>
</div>
<div class="paragraph">
<p>但为什么 Jane Smith 也作为结果返回了呢？原因是她的 <code>about</code> 属性里提到了 <code>rock'' 。因为只有 </code>rock'' 而没有 ``climbing'' ，所以她的相关性得分低于 John 的。</p>
</div>
<div class="paragraph">
<p>这是一个很好的案例，阐明了 Elasticsearch 如何 <em>在</em> 全文属性上搜索并返回相关性最强的结果。Elasticsearch中的 <em>相关性</em>  概念非常重要，也是完全区别于传统关系型数据库的一个概念，数据库中的一条记录要么匹配要么不匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_phrase_search">短语搜索</h3>
<div class="paragraph">
<p>找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者_短语_ 。 比如， 我们想执行这样一个查询，仅匹配同时包含 <code>rock'' <em>和</em> </code>climbing'' ，<em>并且</em>  二者以短语 ``rock climbing'' 的形式紧挨着的雇员记录。</p>
</div>
<div class="paragraph">
<p>为此对 <code>match</code> 查询稍作调整，使用一个叫做 <code>match_phrase</code> 的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>毫无悬念，返回结果仅有 John Smith 的文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": {
      "total":      1,
      "max_score":  0.23013961,
      "hits": [
         {
            ...
            "_score":         0.23013961,
            "_source": {
               "first_name":  "John",
               "last_name":   "Smith",
               "age":         25,
               "about":       "I love to go rock climbing",
               "interests": [ "sports", "music" ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="highlighting-intro">高亮搜索</h3>
<div class="paragraph">
<p>许多应用都倾向于在每个搜索结果中 <em>高亮</em>  部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。</p>
</div>
<div class="paragraph">
<p>再次执行前面的查询，并增加一个新的 <code>highlight</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "query" : {
        "match_phrase" : {
            "about" : "rock climbing"
        }
    },
    "highlight": {
        "fields" : {
            "about" : {}
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 <code>highlight</code> 的部分。这个部分包含了 <code>about</code> 属性匹配的文本片段，并以 HTML 标签 <code>&lt;em&gt;&lt;/em&gt;</code> 封装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": {
      "total":      1,
      "max_score":  0.23013961,
      "hits": [
         {
            ...
            "_score":         0.23013961,
            "_source": {
               "first_name":  "John",
               "last_name":   "Smith",
               "age":         25,
               "about":       "I love to go rock climbing",
               "interests": [ "sports", "music" ]
            },
            "highlight": {
               "about": [
                  "I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;" <b class="conum">(1)</b>
               ]
            }
         }
      ]
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>原始文本中的高亮片段</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>关于高亮搜索片段，可以在 {ref}/search-request-highlighting.html[highlighting reference documentation] 了解更多信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_analytics">分析</h3>
<div class="paragraph">
<p>终于到了最后一个业务需求：支持管理者对雇员目录做分析。 Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 <code>GROUP BY</code> 类似但更强大。</p>
</div>
<div class="paragraph">
<p>举个例子，挖掘出雇员中最受欢迎的兴趣爱好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
  "aggs": {
    "all_interests": {
      "terms": { "field": "interests" }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>暂时忽略掉语法，直接看看结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   ...
   "hits": { ... },
   "aggregations": {
      "all_interests": {
         "buckets": [
            {
               "key":       "music",
               "doc_count": 2
            },
            {
               "key":       "forestry",
               "doc_count": 1
            },
            {
               "key":       "sports",
               "doc_count": 1
            }
         ]
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以看到，两位员工对音乐感兴趣，一位对林地感兴趣，一位对运动感兴趣。这些聚合并非预先统计，而是从匹配当前查询的文档中即时生成。如果想知道叫 Smith 的雇员中最受欢迎的兴趣爱好，可以直接添加适当的查询来组合查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
  "query": {
    "match": {
      "last_name": "smith"
    }
  },
  "aggs": {
    "all_interests": {
      "terms": {
        "field": "interests"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>all_interests</code> 聚合已经变为只包含匹配查询的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  ...
  "all_interests": {
     "buckets": [
        {
           "key": "music",
           "doc_count": 2
        },
        {
           "key": "sports",
           "doc_count": 1
        }
     ]
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>聚合还支持分级汇总  。比如，查询特定兴趣爱好员工的平均年龄：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /megacorp/employee/_search
{
    "aggs" : {
        "all_interests" : {
            "terms" : { "field" : "interests" },
            "aggs" : {
                "avg_age" : {
                    "avg" : { "field" : "age" }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>得到的聚合结果有点儿复杂，但理解起来还是很简单的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">  ...
  "all_interests": {
     "buckets": [
        {
           "key": "music",
           "doc_count": 2,
           "avg_age": {
              "value": 28.5
           }
        },
        {
           "key": "forestry",
           "doc_count": 1,
           "avg_age": {
              "value": 35
           }
        },
        {
           "key": "sports",
           "doc_count": 1,
           "avg_age": {
              "value": 25
           }
        }
     ]
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出基本是第一次聚合的加强版。依然有一个兴趣及数量的列表，只不过每个兴趣都有了一个附加的 <code>avg_age</code> 属性，代表有这个兴趣爱好的所有员工的平均年龄。</p>
</div>
<div class="paragraph">
<p>即使现在不太理解这些语法也没有关系，依然很容易了解到复杂聚合及分组通过 Elasticsearch 特性实现得很完美。可提取的数据类型毫无限制。</p>
</div>
</div>
<div class="sect2">
<h3 id="_tutorial_conclusion">教程结语</h3>
<div class="paragraph">
<p>欣喜的是，这是一个关于 Elasticsearch 基础描述的教程，且仅仅是浅尝辄止，更多诸如 suggestions、geolocation、percolation、fuzzy 与 partial matching 等特性均被省略，以便保持教程的简洁。但它确实突显了开始构建高级搜索功能多么容易。不需要配置——只需要添加数据并开始搜索！</p>
</div>
<div class="paragraph">
<p>很可能语法会让你在某些地方有所困惑，并且对各个方面如何微调也有一些问题。没关系！本书后续内容将针对每个问题详细解释，让你全方位地理解 Elasticsearch 的工作原理。</p>
</div>
</div>
<div class="sect2">
<h3 id="_distributed_nature">分布式特性</h3>
<div class="paragraph">
<p>在本章开头，我们提到过 Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。我们的教程给出了一些使用 Elasticsearch 的示例，但并不涉及任何内部机制。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 在分布式方面几乎是透明的。教程中并不要求了解分布式系统、分片、集群发现或其他的各种分布式概念。可以使用笔记本上的单节点轻松地运行教程里的程序，但如果你想要在 100 个节点的集群上运行程序，一切依然顺畅。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>分配文档到不同的容器 或 <em>分片</em> 中，文档可以储存在一个或多个节点中</p>
</li>
<li>
<p>按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡</p>
</li>
<li>
<p>复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失</p>
</li>
<li>
<p>将集群中任一节点的请求路由到存有相关数据的节点</p>
</li>
<li>
<p>集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当阅读本书时，将会遇到有关 Elasticsearch 分布式特性的补充章节。这些章节将介绍有关集群扩容、故障转移(<a href="#distributed-cluster">集群内的原理</a>) 、应对文档存储(<a href="#distributed-docs">分布式文档存储</a>) 、执行分布式搜索(<a href="#distributed-search">执行分布式检索</a>) ，以及分区（shard）及其工作原理(<a href="#inside-a-shard">分片内部原理</a>) 。</p>
</div>
<div class="paragraph">
<p>这些章节并非必读，完全可以无需了解内部机制就使用 Elasticsearch，但是它们将从另一个角度帮助你了解更完整的 Elasticsearch 知识。可以根据需要跳过它们，或者想更完整地理解时再回头阅读也无妨。</p>
</div>
</div>
<div class="sect2">
<h3 id="_next_steps">后续步骤</h3>
<div class="paragraph">
<p>现在对于通过 Elasticsearch 能够实现什么样的功能、以及上手的简易程度应该有了初步概念。Elasticsearch 力图通过最少的知识和配置做到开箱即用。学习 Elasticsearch 的最好方式是投入实践：尽管开始索引和搜索吧！</p>
</div>
<div class="paragraph">
<p>然而，对于 Elasticsearch 知道得越多，就越有生产效率。告诉 Elasticsearch 越多的领域知识，就越容易进行结果调优。</p>
</div>
<div class="paragraph">
<p>本书的后续内容将帮助你从新手成长为专家，每个章节不仅阐述必要的基础知识，而且包含专家建议。如果刚刚上手，这些建议可能无法立竿见影；但 Elasticsearch 有着合理的默认设置，在无需干预的情况下通常都能工作得很好。当追求毫秒级的性能提升时，随时可以重温这些章节。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-cluster">集群内的原理</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">补充章节</div>
<div class="paragraph">
<p>如前文所述，这是补充章节中第一篇介绍 Elasticsearch 在分布式环境中的运行原理。
在这个章节中，我们将会介绍 <em>cluster</em> 、 <em>node</em> 、 <em>shard</em> 等常用术语，Elastisearch 的扩容机制，
以及如何处理硬件故障的内容。</p>
</div>
<div class="paragraph">
<p>虽然这个章节不是必读的&#8212;&#8203;您完全可以在不关注分片、副本和失效切换等内容的情况下长期使用Elasticsearch--
但是这将帮助你了解 Elasticsearch 的内部工作过程。您可以先快速阅览该章节，将来有需要时再次查看。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>ElasticSearch 的主旨是随时可用和按需扩容。
而扩容可以通过购买性能更强大（ <em>垂直扩容</em> ，或 <em>纵向扩容</em> ）
或者数量更多的服务器（ <em>水平扩容</em> ，或 <em>横向扩容</em> ）来实现。</p>
</div>
<div class="paragraph">
<p>虽然 Elasticsearch 可以获益于更强大的硬件设备，但是垂直扩容是有极限的。
真正的扩容能力是来自于水平扩容&#8212;&#8203;为集群添加更多的节点，并且将负载压力和稳定性分散到这些节点中。</p>
</div>
<div class="paragraph">
<p>对于大多数的数据库而言，通常需要对应用程序进行非常大的改动，才能利用上横向扩容的新增资源。
与之相反的是，ElastiSearch天生就是 <em>分布式的</em> ，它知道如何通过管理多节点来提高扩容性和可用性。
这也意味着你的应用无需关注这个问题。</p>
</div>
<div class="paragraph">
<p>本章将讲述如何按需配置集群、节点和分片，并在硬件故障时确保数据安全。</p>
</div>
<div class="sect2">
<h3 id="_an-empty-cluster">空集群</h3>
<div class="paragraph">
<p>如果我们启动了一个单独的节点，里面不包含任何的数据和索引，那我们的集群看起来就是一个
<a href="#img-cluster">包含空内容节点的集群</a>。</p>
</div>
<div id="img-cluster" class="imageblock">
<div class="content">
<img src="images/elas_0201.png" alt="包含空内容节点的集群">
</div>
<div class="title">Figure 1. 包含空内容节点的集群</div>
</div>
<div class="paragraph">
<p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同 <code>cluster.name</code> 配置的节点组成，
它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
</div>
<div class="paragraph">
<p>当一个节点被选举成为 <em>主</em> 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。
而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。
任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p>
</div>
<div class="paragraph">
<p>作为用户，我们可以将请求发送到 <em>集群中的任何节点</em> ，包括主节点。
每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。
无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。
Elasticsearch 对这一切的管理都是透明的。</p>
</div>
</div>
<div class="sect2">
<h3 id="cluster-health">集群健康</h3>
<div class="paragraph">
<p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 <em>集群健康</em> ，
它在 <code>status</code> 字段中展示为 <code>green</code> 、 <code>yellow</code> 或者 <code>red</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_cluster/health</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "cluster_name":          "elasticsearch",
   "status":                "green", <b class="conum">(1)</b>
   "timed_out":             false,
   "number_of_nodes":       1,
   "number_of_data_nodes":  1,
   "active_primary_shards": 0,
   "active_shards":         0,
   "relocating_shards":     0,
   "initializing_shards":   0,
   "unassigned_shards":     0
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>status</code> 字段是我们最关心的。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>status</code> 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>green</code></dt>
<dd>
<p>所有的主分片和副本分片都正常运行。</p>
</dd>
<dt class="hdlist1"><code>yellow</code></dt>
<dd>
<p>所有的主分片都正常运行，但不是所有的副本分片都正常运行。</p>
</dd>
<dt class="hdlist1"><code>red</code></dt>
<dd>
<p>有主分片没能正常运行。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在本章节剩余的部分，我们将解释什么是 <em>主</em> 分片和 <em>副本</em> 分片，以及上面提到的这些颜色的实际意义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_add-an-index">添加索引</h3>
<div class="paragraph">
<p>我们往 Elasticsearch 添加数据时需要用到 <em>索引</em> —— 保存相关数据的地方。
索引实际上是指向一个或者多个物理 <em>分片</em> 的 <em>逻辑命名空间</em> 。</p>
</div>
<div class="paragraph">
<p>一个 <em>分片</em> 是一个底层的 <em>工作单元</em> ，它仅保存了全部数据中的一部分。
在<a href="#inside-a-shard"><code>分片内部机制</code></a>中，我们将详细介绍分片是如何工作的，而现在我们只需知道一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。
我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。
当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
</div>
<div class="paragraph">
<p>一个分片可以是 <em>主</em> 分片或者 <em>副本</em> 分片。
索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>技术上来说，一个主分片最大能够存储 Integer.MAX_VALUE - 128 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件，
文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个副本分片只是一个主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
</div>
<div class="paragraph">
<p>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。</p>
</div>
<div class="paragraph">
<p>让我们在包含一个空节点的集群内创建名为 <code>blogs</code> 的索引。
索引在默认情况下会被分配5个主分片，
但是为了演示目的，我们将分配3个主分片和一份副本（每个主分片拥有一个副本分片）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /blogs
{
   "settings" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 1
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的集群现在是<a href="#cluster-one-node">拥有一个索引的单节点集群</a>。所有3个主分片都被分配在 <code>Node 1</code> 。</p>
</div>
<div id="cluster-one-node" class="imageblock">
<div class="content">
<img src="images/elas_0202.png" alt="拥有一个索引的单节点集群">
</div>
<div class="title">Figure 2. 拥有一个索引的单节点集群</div>
</div>
<div class="paragraph">
<p>如果我们现在查看<a href="#cluster-health"><code>集群健康</code></a>，我们将看到如下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "cluster_name": "elasticsearch",
  "status": "yellow", <b class="conum">(1)</b>
  "timed_out": false,
  "number_of_nodes": 1,
  "number_of_data_nodes": 1,
  "active_primary_shards": 3,
  "active_shards": 3,
  "relocating_shards": 0,
  "initializing_shards": 0,
  "unassigned_shards": 3, <b class="conum">(2)</b>
  "delayed_unassigned_shards": 0,
  "number_of_pending_tasks": 0,
  "number_of_in_flight_fetch": 0,
  "task_max_waiting_in_queue_millis": 0,
  "active_shards_percent_as_number": 50
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>集群 <code>status</code> 值为 <code>yellow</code> 。</p>
</li>
<li>
<p>没有被分配到任何节点的副本数。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>集群的健康状况为 <code>yellow</code> 则表示全部 <em>主</em> 分片都正常运行（集群可以正常服务所有请求），但是 <em>副本</em> 分片没有全部处在正常状态。
实际上，所有3个副本分片都是 <code>unassigned</code> —— 它们都没有被分配到任何节点。
在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p>
</div>
<div class="paragraph">
<p>当前我们的集群是正常运行的，但是在硬件故障时有丢失数据的风险。</p>
</div>
</div>
<div class="sect2">
<h3 id="_add_failover">添加故障转移</h3>
<div class="paragraph">
<p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。
幸运的是，我们只需再启动一个节点即可防止数据丢失。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">启动第二个节点</div>
<div class="paragraph">
<p>为了测试第二个节点启动后的情况，你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考<a href="#running-elasticsearch">安装并运行 Elasticsearch</a>）。多个节点可以共享同一个目录。</p>
</div>
<div class="paragraph">
<p>当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 <code>cluster.name</code> 配置，它就会自动发现集群并加入到其中。
但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。
详细信息请查看<a href="#unicast">[unicast]</a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>如果启动了第二个节点，我们的集群将会如<a href="#cluster-two-nodes">拥有两个节点的集群——所有主分片和副本分片都已被分配</a>所示。</p>
</div>
<div id="cluster-two-nodes" class="imageblock">
<div class="content">
<img src="images/elas_0203.png" alt="拥有两个节点的集群">
</div>
<div class="title">Figure 3. 拥有两个节点的集群——所有主分片和副本分片都已被分配</div>
</div>
<div class="paragraph">
<p>当第二个节点加入到集群后，3个 <em>副本分片</em> 将会分配到这个节点上——每个主分片对应一个副本分片。
这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p>
</div>
<div class="paragraph">
<p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p>
</div>
<div class="paragraph">
<p><code>cluster-health</code> 现在展示的状态为 <code>green</code> ，这表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "cluster_name": "elasticsearch",
  "status": "green", <b class="conum">(1)</b>
  "timed_out": false,
  "number_of_nodes": 2,
  "number_of_data_nodes": 2,
  "active_primary_shards": 3,
  "active_shards": 6,
  "relocating_shards": 0,
  "initializing_shards": 0,
  "unassigned_shards": 0,
  "delayed_unassigned_shards": 0,
  "number_of_pending_tasks": 0,
  "number_of_in_flight_fetch": 0,
  "task_max_waiting_in_queue_millis": 0,
  "active_shards_percent_as_number": 100
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>集群 <code>status</code> 值为 <code>green</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们的集群现在不仅仅是正常运行的，并且还处于 <em>始终可用</em> 的状态。</p>
</div>
</div>
<div class="sect2">
<h3 id="_scale_horizontally">水平扩容</h3>
<div class="paragraph">
<p>怎样为我们的正在增长中的应用程序按需扩容呢？
当启动了第三个节点，我们的集群将会看起来如<a href="#cluster-three-nodes">拥有三个节点的集群——为了分散负载而对分片进行重新分配</a>所示。</p>
</div>
<div id="cluster-three-nodes" class="imageblock">
<div class="content">
<img src="images/elas_0204.png" alt="拥有三个节点的集群">
</div>
<div class="title">Figure 4. 拥有三个节点的集群——为了分散负载而对分片进行重新分配</div>
</div>
<div class="paragraph">
<p><code>Node 1</code> 和 <code>Node 2</code> 上各有一个分片被迁移到了新的 <code>Node 3</code> 节点，现在每个节点上都拥有2个分片，而不是之前的3个。
这表示每个节点的硬件资源（CPU, RAM, I/O）将被更少的分片所共享，每个分片的性能将会得到提升。</p>
</div>
<div class="paragraph">
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。
我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p>
</div>
<div class="sect3">
<h4 id="_更多的扩容">更多的扩容</h4>
<div class="paragraph">
<p>但是如果我们想要扩容超过6个节点怎么办呢？</p>
</div>
<div class="paragraph">
<p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够 <em>存储</em> 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。）
但是，读操作——搜索和返回数据——可以同时被主分片 <em>或</em> 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p>
</div>
<div class="paragraph">
<p>在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 <code>1</code> 增加到 <code>2</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /blogs/_settings
{
   "number_of_replicas" : 2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如<a href="#cluster-three-nodes-two-replicas">将参数 <code>number_of_replicas</code> 调大到 2</a>所示， <code>blogs</code> 索引现在拥有9个分片：3个主分片和6个副本分片。
这意味着我们可以将集群扩容到9个节点，每个节点上一个分片。相比原来3个节点时，集群搜索性能可以提升 <em>3</em> 倍。</p>
</div>
<div id="cluster-three-nodes-two-replicas" class="imageblock">
<div class="content">
<img src="images/elas_0205.png" alt="拥有2份副本分片3个节点的集群">
</div>
<div class="title">Figure 5. 将参数 <code>number_of_replicas</code> 调大到 2</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。
你需要增加更多的硬件资源来提升吞吐量。</p>
</div>
<div class="paragraph">
<p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去2个节点的情况下不丢失任何数据。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_coping_with_failure">应对故障</h3>
<div class="paragraph">
<p>我们之前说过 Elasticsearch 可以应对节点故障，接下来让我们尝试下这个功能。

如果我们关闭第一个节点，这时集群的状态为<a href="#cluster-post-kill">关闭了一个节点后的集群</a></p>
</div>
<div id="cluster-post-kill" class="imageblock">
<div class="content">
<img src="images/elas_0206.png" alt="关闭了一个节点后的集群">
</div>
<div class="title">Figure 6. 关闭了一个节点后的集群</div>
</div>
<div class="paragraph">
<p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： <code>Node 2</code> 。</p>
</div>
<div class="paragraph">
<p>在我们关闭 <code>Node 1</code> 的同时也失去了主分片 <code>1</code> 和 <code>2</code> ，并且在缺失主分片的时候索引也不能正常工作。

如果此时来检查集群的状况，我们看到的状态将会为 <code>red</code> ：不是所有主分片都在正常工作。</p>
</div>
<div class="paragraph">
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本，
所以新的主节点立即将这些分片在 <code>Node 2</code> 和 <code>Node 3</code> 上对应的副本分片提升为主分片，
此时集群的状态将会为 <code>yellow</code> 。
这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
</div>
<div class="paragraph">
<p>为什么我们集群状态是 <code>yellow</code> 而不是 <code>green</code> 呢？
虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应2份副本分片，而此时只存在一份副本分片。
所以集群不能为 <code>green</code> 的状态，不过我们不必过于担心：如果我们同样关闭了 <code>Node 2</code> ，我们的程序 <em>依然</em> 可以保持在不丢任何数据的情况下运行，因为 <code>Node 3</code> 为每一个分片都保留着一份副本。</p>
</div>
<div class="paragraph">
<p>如果我们重新启动 <code>Node 1</code> ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如<a href="#cluster-three-nodes-two-replicas">将参数 <code>number_of_replicas</code> 调大到 2</a>所示。
如果 <code>Node 1</code> 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
</div>
<div class="paragraph">
<p>到目前为止，你应该对分片如何使得 Elasticsearch 进行水平扩容以及数据保障等知识有了一定了解。
接下来我们将讲述关于分片生命周期的更多细节。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-in-data-out">数据输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>无论我们写什么样的程序，目的都是一样的：以某种方式组织数据服务我们的目的。
但是数据不仅仅由随机位和字节组成。我们建立数据元素之间的关系以便于表示实体，或者现实世界中存在的 <em>事物</em> 。
如果我们知道一个名字和电子邮件地址属于同一个人，那么它们将会更有意义。</p>
</div>
<div class="paragraph">
<p>尽管在现实世界中，不是所有的类型相同的实体看起来都是一样的。
一个人可能有一个家庭电话号码，而另一个人只有一个手机号码，再一个人可能两者兼有。
一个人可能有三个电子邮件地址，而另一个人却一个都没有。一位西班牙人可能有两个姓，而讲英语的人可能只有一个姓。</p>
</div>
<div class="paragraph">
<p>面向对象编程语言如此流行的原因之一是对象帮我们表示和处理现实世界具有潜在的复杂的数据结构的实体，到目前为止，一切都很完美！</p>
</div>
<div class="paragraph">
<p>但是当我们需要存储这些实体时问题来了，传统上，我们以行和列的形式存储数据到关系型数据库中，相当于使用电子表格。
正因为我们使用了这种不灵活的存储媒介导致所有我们使用对象的灵活性都丢失了。</p>
</div>
<div class="paragraph">
<p>但是否我们可以将我们的对象按对象的方式来存储？这样我们就能更加专注于 <em>使用</em> 数据，而不是在电子表格的局限性下对我们的应用建模。
我们可以重新利用对象的灵活性。</p>
</div>
<div class="paragraph">
<p>一个 <em>对象</em> 是基于特定语言的内存的数据结构。为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。
<a href="http://en.wikipedia.org/wiki/Json">JSON</a> 是一种以人可读的文本表示对象的方法。

它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 <em>JSON 文档</em> 。</p>
</div>
<div class="paragraph">
<p>Elastcisearch 是分布式的 <em>文档</em> 存储。它能存储和检索复杂的数据结构&#8212;&#8203;序列化成为JSON文档&#8212;&#8203;以 <em>实时</em> 的方式。
换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。</p>
</div>
<div class="paragraph">
<p>当然，我们不仅要存储数据，我们一定还需要查询它，成批且快速的查询它们。
尽管现存的 NoSQL 解决方案允许我们以文档的形式存储对象，但是他们仍旧需要我们思考如何查询我们的数据，以及确定哪些字段需要被索引以加快数据检索。</p>
</div>
<div class="paragraph">
<p>在 Elasticsearch 中， <em>每个字段的所有数据</em> 都是 <em>默认被索引的</em> 。
即每个字段都有为了快速检索设置的专用倒排索引。而且，不像其他多数的数据库，它能在 <em>相同的查询中</em> 使用所有这些倒排索引，并以惊人的速度返回结果。</p>
</div>
<div class="paragraph">
<p>在本章中，我们展示了用来创建，检索，更新和删除文档的 API。就目前而言，我们不关心文档中的数据或者怎样查询它们。
所有我们关心的就是在 Elasticsearch 中怎样安全的存储文档，以及如何将文档再次返回。</p>
</div>
<div class="sect2">
<h3 id="document">什么是文档?</h3>
<div class="paragraph">
<p>在大多数应用中，多数实体或对象可以被序列化为包含键值对的 JSON 对象。

一个 <em>键</em> 可以是一个字段或字段的名称，一个 <em>值</em> 可以是一个字符串，一个数字，一个布尔值，
另一个对象，一些数组值，或一些其它特殊类型诸如表示日期的字符串，或代表一个地理位置的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "name":         "John Smith",
    "age":          42,
    "confirmed":    true,
    "join_date":    "2014-06-01",
    "home": {
        "lat":      51.5,
        "lon":      0.1
    },
    "accounts": [
        {
            "type": "facebook",
            "id":   "johnsmith"
        },
        {
            "type": "twitter",
            "id":   "johnsmith"
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下，我们使用的术语 <em>对象</em> 和 <em>文档</em> 是可以互相替换的。不过，有一个区别：
一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。
对象可能包含了另外一些对象。在 Elasticsearch 中，术语 <em>文档</em> 有着特定的含义。它是指最顶层或者根对象,
这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
字段的名字可以是任何合法的字符串，但不可以包含时间段。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_Document_Metadata">文档元数据</h3>
<div class="paragraph">
<p>一个文档不仅仅包含它的数据 ，也包含 <em>元数据</em> &#x2014;&#x2014; <em>有关</em> 文档的信息。
三个必须的元数据元素如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>文档在哪存放</p>
</dd>
<dt class="hdlist1"><code>_type</code></dt>
<dd>
<p>文档表示的对象类别</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>文档唯一标识</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_index">_index</h4>
<div class="paragraph">
<p>一个 <em>索引</em> 应该是因共同的特性被分组到一起的文档集合。
例如，你可能存储所有的产品在索引 <code>products</code> 中，而存储所有销售的交易到索引 <code>sales</code> 中。
虽然也允许存储不相关的数据到一个索引中，但这通常看作是一个反模式的做法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 <em>分片</em> 中，而一个索引仅仅是逻辑上的命名空间，
这个命名空间由一个或者多个分片组合在一起。
然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 <em>索引</em> 内。
Elasticsearch 会处理所有的细节。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们将在 <a href="#index-management">索引管理</a> 介绍如何自行创建和管理索引，但现在我们将让 Elasticsearch 帮我们创建索引。
所有需要我们做的就是选择一个索引名，这个名字必须小写，不能以下划线开头，不能包含逗号。我们用 <code>website</code> 作为索引名举例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_type">_type</h4>
<div class="paragraph">
<p>数据可能在索引中只是松散的组合在一起，但是通常明确定义一些数据中的子分区是很有用的。
例如，所有的产品都放在一个索引中，但是你有许多不同的产品类别，比如 "electronics" 、 "kitchen" 和 "lawn-care"。</p>
</div>
<div class="paragraph">
<p>这些文档共享一种相同的（或非常相似）的模式：他们有一个标题、描述、产品代码和价格。他们只是正好属于“产品”下的一些子类。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 公开了一个称为 <em>types</em> （类型）的特性，它允许您在索引中对数据进行逻辑分区。不同 types 的文档可能有不同的字段，但最好能够非常相似。
我们将在 <a href="#mapping">类型和映射</a> 中更多的讨论关于 types 的一些应用和限制。</p>
</div>
<div class="paragraph">
<p>一个  <code>_type</code> 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号，
并且长度限制为256个字符. 我们使用 <code>blog</code> 作为类型名举例。</p>
</div>
</div>
<div class="sect3">
<h4 id="_id">_id</h4>
<div class="paragraph">
<p><em>ID</em> 是一个字符串，当它和 <code>_index</code> 以及 <code>_type</code> 组合就可以唯一确定 Elasticsearch 中的一个文档。
当你创建一个新的文档，要么提供自己的 <code>_id</code> ，要么让 Elasticsearch 帮你生成。</p>
</div>
</div>
<div class="sect3">
<h4 id="_Other_Metadata">其他元数据</h4>
<div class="paragraph">
<p>还有一些其他的元数据元素，他们在 <a href="#mapping">类型和映射</a> 进行了介绍。通过前面已经列出的元数据元素，
我们已经能存储文档到 Elasticsearch 中并通过 ID 检索它&#8212;&#8203;换句话说，使用 Elasticsearch 作为文档的存储介质。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="index-doc">索引文档</h3>
<div class="paragraph">
<p>通过使用 <code>index</code> API ，文档可以被 <em>索引</em> &#x2014;&#x2014; 存储和使文档可被搜索。
但是首先，我们要确定文档的位置。正如我们刚刚讨论的，一个文档的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 唯一标识一个文档。
我们可以提供自定义的 <code>_id</code> 值，或者让 <code>index</code> API 自动生成。</p>
</div>
<div class="sect3">
<h4 id="_Using_Our_Own_ID">使用自定义的 ID</h4>
<div class="paragraph">
<p>如果你的文档有一个自然的标识符
（例如，一个 <code>user_account</code> 字段或其他标识文档的值），你应该使用如下方式的 <code>index</code> API 并提供你自己 <code>_id</code> ：</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /{index}/{type}/{id}
{
  "field": "value",
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>举个例子，如果我们的索引称为 <code>website</code> ，类型称为 <code>blog</code> ，并且选择 <code>123</code> 作为 ID ，那么索引请求应该是下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "Just trying this out...",
  "date":  "2014/01/01"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch 响应体如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "123",
   "_version":  1,
   "created":   true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该响应表明文档已经成功创建，该索引包括 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 元数据，
以及一个新元素： <code>_version</code> 。</p>
</div>
<div class="paragraph">
<p>在 Elasticsearch 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， <code>_version</code> 的值会递增。
在 <a href="#version-control">处理冲突</a> 中，我们讨论了怎样使用 <code>_version</code> 号码确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="_autogenerating_ids">Autogenerating IDs</h4>
<div class="paragraph">
<p>如果你的数据没有自然的 ID， Elasticsearch 可以帮我们自动生成 ID 。
请求的结构调整为：
不再使用 <code>PUT</code> 谓词(“使用这个 URL 存储这个文档”)，
而是使用 <code>POST</code> 谓词(“存储文档在这个 URL 命名空间下”)。</p>
</div>
<div class="paragraph">
<p>现在该 URL 只需包含 <code>_index</code> 和 <code>_type</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/
{
  "title": "My second blog entry",
  "text":  "Still trying this out...",
  "date":  "2014/01/01"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了 <code>_id</code> 是 Elasticsearch 自动生成的，响应的其他部分和前面的类似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "AVFgSgVHUP18jI2wRx0w",
   "_version":  1,
   "created":   true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串。
这些 GUID 字符串由可修改的 FlakeID 模式生成，这种模式允许多个节点并行生成唯一 ID ，且互相之间的冲突概率几乎为零。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="get-doc">取回一个文档</h3>
<div class="paragraph">
<p>为了从 Elasticsearch 中检索出文档，我们仍然使用相同的 <code>_index</code> , <code>_type</code> , 和  <code>_id</code> ，但是 HTTP 谓词更改为 <code>GET</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123?pretty</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体包括目前已经熟悉了的元数据元素，再加上  <code>_source</code> 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out...",
      "date":  "2014/01/01"
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>在请求的查询串参数中加上 <code>pretty</code> 参数，正如前面的例子中看到的，这将会调用 Elasticsearch 的 <em>pretty-print</em> 功能，该功能 使得 JSON 响应体更加可读。但是， <code>_source</code> 字段不能被格式化打印出来。相反，我们得到的 <code>_source</code> 字段中的 JSON 串，刚好是和我们传给它的一样。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>GET 请求的响应体包括 <code>{"found": true}</code> ，这证实了文档已经被找到。 如果我们请求一个不存在的文档，我们仍旧会得到一个 JSON 响应体，但是  <code>found</code> 将会是 <code>false</code> 。
此外， HTTP 响应码将会是 <code>404 Not Found</code> ，而不是 <code>200 OK</code> 。</p>
</div>
<div class="paragraph">
<p>我们可以通过传递 <code>-i</code> 参数给 <code>curl</code> 命令，该参数能够显示响应的头部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">curl -i -XGET http://localhost:9200/website/blog/124?pretty</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示响应头部的响应体现在类似这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 404 Not Found
Content-Type: application/json; charset=UTF-8
Content-Length: 83

{
  "_index" : "website",
  "_type" :  "blog",
  "_id" :    "124",
  "found" :  false
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_返回文档的一部分">返回文档的一部分</h4>
<div class="paragraph">
<p>默认情况下， <code>GET</code> 请求会返回整个文档，这个文档正如存储在 <code>_source</code> 字段中的一样。但是也许你只对其中的 <code>title</code> 字段感兴趣。单个字段能用 <code>_source</code> 参数请求得到，多个字段也能使用逗号分隔的列表来指定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123?_source=title,text</code></pre>
</div>
</div>
<div class="paragraph">
<p>该 <code>_source</code> 字段现在包含的只是我们请求的那些字段，并且已经将 <code>date</code> 字段过滤掉了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 1,
  "found" :   true,
  "_source" : {
      "title": "My first blog entry" ,
      "text":  "Just trying this out..."
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果你只想得到 <code>_source</code> 字段，不需要任何元数据，你能使用 <code>_source</code> 端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /website/blog/123/_source</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么返回的的内容如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "title": "My first blog entry",
   "text":  "Just trying this out...",
   "date":  "2014/01/01"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="doc-exists">检查文档是否存在</h3>
<div class="paragraph">
<p>如果只想检查一个文档是否存在--根本不想关心内容&#8212;&#8203;那么用 <code>HEAD</code> 方法来代替 <code>GET</code> 方法。 <code>HEAD</code> 请求没有返回体，只返回一个 HTTP 请求报头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -i -XHEAD http://localhost:9200/website/blog/123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档存在， Elasticsearch 将返回一个 <code>200 ok</code> 的状态码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>若文档不存在， Elasticsearch 将返回一个 <code>404 Not Found</code> 的状态码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">curl -i -XHEAD http://localhost:9200/website/blog/124</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">HTTP/1.1 404 Not Found
Content-Type: text/plain; charset=UTF-8
Content-Length: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，一个文档仅仅是在检查的时候不存在，并不意味着一毫秒之后它也不存在：也许同时正好另一个进程就创建了该文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="update-doc">更新整个文档</h3>
<div class="paragraph">
<p>在 Elasticsearch 中文档是 <em>不可改变</em> 的，不能修改它们。相反，如果想要更新现有的文档，需要 <em>重建索引</em> 或者进行替换，
我们可以使用相同的 <code>index</code> API 进行实现，在 <a href="#index-doc">索引文档</a> 中已经进行了讨论。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应体中，我们能看到 Elasticsearch 已经增加了 <code>_version</code> 字段值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 2,
  "created":   false <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>created</code> 标志设置成 <code>false</code> ，是因为相同的索引、类型和 ID 的文档已经存在。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。
尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。</p>
</div>
<div class="paragraph">
<p>在本章的后面部分，我们会介绍 <code>update</code> API, 这个 API 可以用于 <a href="#partial-updates">partial updates to a document</a> 。
虽然它似乎对文档直接进行了修改，但实际上 Elasticsearch 按前述完全相同方式执行以下过程：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>从旧文档构建 JSON</p>
</li>
<li>
<p>更改该 JSON</p>
</li>
<li>
<p>删除旧文档</p>
</li>
<li>
<p>索引一个新文档</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>唯一的区别在于,  <code>update</code> API 仅仅通过一个客户端请求来实现这些步骤，而不需要单独的 <code>get</code> 和 <code>index</code> 请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="create-doc">创建新文档</h3>
<div class="paragraph">
<p>当我们索引一个文档，怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？</p>
</div>
<div class="paragraph">
<p>请记住， <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 的组合可以唯一标识一个文档。所以，确保创建一个新文档的最简单办法是，使用索引请求的 <code>POST</code> 形式让 Elasticsearch 自动生成唯一 <code>_id</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，如果已经有自己的 <code>_id</code> ，那么我们必须告诉 Elasticsearch ，只有在相同的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 不存在时才接受我们的索引请求。这里有两种方式，他们做的实际是相同的事情。使用哪种，取决于哪种使用起来更方便。</p>
</div>
<div class="paragraph">
<p>第一种方法使用 <code>op_type</code> 查询-字符串参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123?op_type=create
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二种方法是在 URL 末端使用 <code>/_create</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/123/_create
{ ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 <code>201 Created</code> 的 HTTP 响应码。</p>
</div>
<div class="paragraph">
<p>另一方面，如果具有相同的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 的文档已经存在，Elasticsearch 将会返回 <code>409 Conflict</code> 响应码，以及如下的错误信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "error": {
      "root_cause": [
         {
            "type": "document_already_exists_exception",
            "reason": "[blog][123]: document already exists",
            "shard": "0",
            "index": "website"
         }
      ],
      "type": "document_already_exists_exception",
      "reason": "[blog][123]: document already exists",
      "shard": "0",
      "index": "website"
   },
   "status": 409
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delete-doc">删除文档</h3>
<div class="paragraph">
<p>删除文档的语法和我们所知道的规则相同，只是使用 <code>DELETE</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /website/blog/123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果找到该文档，Elasticsearch 将要返回一个 <code>200 ok</code> 的 HTTP 响应码，和一个类似以下结构的响应体。注意，字段 <code>_version</code> 值已经增加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "found" :    true,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档没有找到，我们将得到 <code>404 Not Found</code> 的响应码和类似这样的响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "found" :    false,
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 4
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使文档不存在（ <code>Found</code> 是 <code>false</code> ）， <code>_version</code> 值仍然会增加。这是 Elasticsearch 内部记录本的一部分，用来确保这些改变在跨多节点时以正确的顺序执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
正如已经在<a href="#update-doc">更新整个文档</a>中提到的，删除文档不会立即将文档从磁盘中删除，只是将文档标记为已删除状态。随着你不断的索引更多的数据，Elasticsearch 将会在后台清理标记为已删除的文档。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="version-control">处理冲突</h3>
<div class="paragraph">
<p>当我们使用 <code>index</code> API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 <em>整个文档</em> 。
最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p>
</div>
<div class="paragraph">
<p>很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到 Elasticsearch 中并使其可被搜索。
也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。</p>
</div>
<div class="paragraph">
<p>但有时丢失了一个变更就是 <em>非常严重的</em> 。试想我们使用 Elasticsearch 存储我们网上商城商品库存的数量，
每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。</p>
</div>
<div class="paragraph">
<p>有一天，管理层决定做一次促销。突然地，我们一秒要卖好几个商品。
假设有两个 web 程序并行运行，每一个都同时处理所有商品的销售，如图 <a href="#img-data-lww">Consequence of no concurrency control</a> 所示。</p>
</div>
<div id="img-data-lww" class="imageblock" style="text-align: center">
<div class="content">
<img src="images/elas_0301.png" alt="Consequence of no concurrency control" width="50%">
</div>
<div class="title">Figure 7. Consequence of no concurrency control</div>
</div>
<div class="paragraph">
<p><code>web_1</code> 对 <code>stock_count</code> 所做的更改已经丢失，因为 <code>web_2</code> 不知道它的 <code>stock_count</code> 的拷贝已经过期。
结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在，我们将让他们非常失望。</p>
</div>
<div class="paragraph">
<p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。</p>
</div>
<div class="paragraph">
<p>在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>悲观并发控制</em> </dt>
<dd>
<p>这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。
一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</p>
</dd>
<dt class="hdlist1"><em>乐观并发控制</em> </dt>
<dd>
<p>Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。
然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。
例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-concurrency-control">乐观并发控制</h3>
<div class="paragraph">
<p>Elasticsearch 是分布式的。当文档创建、更新或删除时，
新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 <em>顺序是乱的</em> 。
Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p>
</div>
<div class="paragraph">
<p>当我们之前讨论 <code>index</code> ， <code>GET</code> 和 <code>delete</code> 请求时，我们指出每个文档都有一个 <code>_version</code> （版本）号，当文档被修改时版本号递增。
Elasticsearch 使用这个 <code>_version</code> 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p>
</div>
<div class="paragraph">
<p>我们可以利用 <code>_version</code> 号来确保
应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 <code>version</code> 号来达到这个目的。
如果该版本不是当前版本号，我们的请求将会失败。</p>
</div>
<div class="paragraph">
<p>让我们创建一个新的博客文章：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/1/_create
{
  "title": "My first blog entry",
  "text":  "Just trying this out..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体告诉我们，这个新创建的文档 <code>_version</code> 版本号是 <code>1</code> 。现在假设我们想编辑这个文档：我们加载其数据到 web 表单中，
做一些修改，然后保存新的版本。</p>
</div>
<div class="paragraph">
<p>首先我们检索文档:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应体包含相同的 <code>_version</code> 版本号 <code>1</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "1",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out..."
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，当我们尝试通过重建文档的索引来保存修改，我们指定 <code>version</code> 为我们的修改会被应用的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/1?version=1 <b class="conum">(1)</b>
{
  "title": "My first blog entry",
  "text":  "Starting to get the hang of this..."
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>我们想这个在我们索引中的文档只有现在的 <code>_version</code> 为 <code>1</code> 时，本次更新才能成功。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此请求成功，并且响应体告诉我们 <code>_version</code> 已经递增到 <code>2</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "1",
  "_version": 2
  "created":  false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，如果我们重新运行相同的索引请求，仍然指定 <code>version=1</code> ，
Elasticsearch 返回 <code>409 Conflict</code> HTTP 响应码，和一个如下所示的响应体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "error": {
      "root_cause": [
         {
            "type": "version_conflict_engine_exception",
            "reason": "[blog][1]: version conflict, current [2], provided [1]",
            "index": "website",
            "shard": "3"
         }
      ],
      "type": "version_conflict_engine_exception",
      "reason": "[blog][1]: version conflict, current [2], provided [1]",
      "index": "website",
      "shard": "3"
   },
   "status": 409
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们在 Elasticsearch 中这个文档的当前 <code>_version</code> 号是 <code>2</code> ，但我们指定的更新版本号为 <code>1</code> 。</p>
</div>
<div class="paragraph">
<p>我们现在怎么做取决于我们的应用需求。我们可以告诉用户说其他人已经修改了文档，并且在再次保存之前检查这些修改内容。
或者，在之前的商品 <code>stock_count</code> 场景，我们可以获取到最新的文档并尝试重新应用这些修改。</p>
</div>
<div class="paragraph">
<p>所有文档的更新或删除 API，都可以接受 <code>version</code> 参数，这允许你在代码中使用乐观的并发控制，这是一种明智的做法。</p>
</div>
<div class="sect3">
<h4 id="_Using_Versions_from_an_External_System">通过外部系统使用版本控制</h4>
<div class="paragraph">
<p>一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索，

这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p>
</div>
<div class="paragraph">
<p>如果你的主数据库已经有了版本号&#8201;&#8212;&#8201;或一个能作为版本号的字段值比如 <code>timestamp</code>&#8201;&#8212;&#8201;那么你就可以在 Elasticsearch 中通过增加 <code>version_type=external</code> 到查询字符串的方式重用这些相同的版本号，
版本号必须是大于零的整数，
且小于 <code>9.2E+18</code>&#8201;&#8212;&#8201;一个 Java 中 <code>long</code> 类型的正值。</p>
</div>
<div class="paragraph">
<p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同，
Elasticsearch 不是检查当前 <code><em>version</code> 和请求中指定的版本号是否相同，
而是检查当前 <code>_version</code> 是否 _小于</em> 指定的版本号。
如果请求成功，外部的版本号作为文档的新 <code>_version</code> 进行存储。</p>
</div>
<div class="paragraph">
<p>外部版本号不仅在索引和删除请求是可以指定，而且在 <em>创建</em> 新文档时也可以指定。</p>
</div>
<div class="paragraph">
<p>例如，要创建一个新的具有外部版本号 <code>5</code> 的博客文章，我们可以按以下方法进行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/2?version=5&amp;version_type=external
{
  "title": "My first external blog entry",
  "text":  "Starting to get the hang of this..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应中，我们能看到当前的 <code>_version</code> 版本号是 <code>5</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 5,
  "created":  true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们更新这个文档，指定一个新的 <code>version</code> 号是 <code>10</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /website/blog/2?version=10&amp;version_type=external
{
  "title": "My first external blog entry",
  "text":  "This is a piece of cake..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请求成功并将当前 <code>_version</code> 设为 <code>10</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 10,
  "created":  false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你要重新运行此请求时，它将会失败，并返回像我们之前看到的同样的冲突错误，
因为指定的外部版本号不大于 Elasticsearch 的当前版本号。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partial-updates">文档的部分更新</h3>
<div class="paragraph">
<p>在 <a href="#update-doc">更新整个文档</a> , 我们已经介绍过
更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 <code>update</code> API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。</p>
</div>
<div class="paragraph">
<p>我们也介绍过文档是不可变的：他们不能被修改，只能被替换。 <code>update</code> API 必须遵循同样的规则。
从外部来看，我们在一个文档的某个位置进行部分更新。然而在内部， <code>update</code> API 简单使用与之前描述相同的 <em>检索-修改-重建索引</em> 的处理过程。
区别在于这个过程发生在分片内部，这样就避免了多次请求的网络开销。通过减少检索和重建索引步骤之间的时间，我们也减少了其他进程的变更带来冲突的可能性。</p>
</div>
<div class="paragraph">
<p><code>update</code> 请求最简单的一种形式是接收文档的一部分作为 <code>doc</code> 的参数，
它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。
例如，我们增加字段 <code>tags</code> 和 <code>views</code> 到我们的博客文章，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "doc" : {
      "tags" : [ "testing" ],
      "views": 0
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求成功，我们看到类似于 <code>index</code> 请求的响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index" :   "website",
   "_id" :      "1",
   "_type" :    "blog",
   "_version" : 3
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检索文档显示了更新后的 <code>_source</code> 字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  3,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags": [ "testing" ], <b class="conum">(1)</b>
      "views":  0 <b class="conum">(1)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>新的字段已被添加到 <code>_source</code> 中。</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_Using_Scripts_to_Make_Partial_Updates">使用脚本部分更新文档</h4>
<div class="paragraph">
<p>脚本可以在 <code>update</code> API中用来改变 <code>_source</code> 的字段内容，
它在更新脚本中称为 <code>ctx._source</code> 。 例如，我们可以使用脚本来增加博客文章中 <code>views</code> 的数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx._source.views+=1"
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">用 Groovy 脚本编程</div>
<div class="paragraph">
<p>对于那些 API 不能满足需求的情况，Elasticsearch 允许你使用脚本编写自定义的逻辑。
许多API都支持脚本的使用，包括搜索、排序、聚合和文档更新。
脚本可以作为请求的一部分被传递，从特殊的 .scripts 索引中检索，或者从磁盘加载脚本。</p>
</div>
<div class="paragraph">
<p>默认的脚本语言 是 <a href="http://groovy.codehaus.org/">Groovy</a>，一种快速表达的脚本语言，在语法上与 JavaScript 类似。
它在 Elasticsearch V1.3.0 版本首次引入并运行在 <em>沙盒</em> 中，然而 Groovy 脚本引擎存在漏洞，
允许攻击者通过构建 Groovy 脚本，在 Elasticsearch Java VM 运行时脱离沙盒并执行 shell 命令。</p>
</div>
<div class="paragraph">
<p>因此，在版本 v1.3.8 、 1.4.3 和 V1.5.0 及更高的版本中，它已经被默认禁用。
此外，您可以通过设置集群中的所有节点的 <code>config/elasticsearch.yml</code> 文件来禁用动态 Groovy 脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">script.groovy.sandbox.enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将关闭 Groovy 沙盒，从而防止动态 Groovy 脚本作为请求的一部分被接受，
或者从特殊的 <code>.scripts</code> 索引中被检索。当然，你仍然可以使用存储在每个节点的 <code>config/scripts/</code> 目录下的 Groovy 脚本。</p>
</div>
<div class="paragraph">
<p>如果你的架构和安全性不需要担心漏洞攻击，例如你的 Elasticsearch 终端仅暴露和提供给可信赖的应用，
当它是你的应用需要的特性时，你可以选择重新启用动态脚本。</p>
</div>
<div class="paragraph">
<p>你可以在 {ref}/modules-scripting.html[scripting reference documentation] 获取更多关于脚本的资料。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以通过使用脚本给 <code>tags</code> 数组添加一个新的标签。在这个例子中，我们指定新的标签作为参数，而不是硬编码到脚本内部。
这使得 Elasticsearch 可以重用这个脚本，而不是每次我们想添加标签时都要对新脚本重新编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx._source.tags+=new_tag",
   "params" : {
      "new_tag" : "search"
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取文档并显示最后两次请求的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "_index":    "website",
   "_type":     "blog",
   "_id":       "1",
   "_version":  5,
   "found":     true,
   "_source": {
      "title":  "My first blog entry",
      "text":   "Starting to get the hang of this...",
      "tags":  ["testing", "search"], <b class="conum">(1)</b>
      "views":  1 <b class="conum">(2)</b>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>search</code> 标签已追加到 <code>tags</code> 数组中。</p>
</li>
<li>
<p><code>views</code> 字段已递增。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们甚至可以选择通过设置 <code>ctx.op</code> 为 <code>delete</code> 来删除基于其内容的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/blog/1/_update
{
   "script" : "ctx.op = ctx._source.views == count ? 'delete' : 'none'",
    "params" : {
        "count": 1
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_Updating_a_Document_That_May_Not_Yet_Exist">更新的文档可能尚不存在</h4>
<div class="paragraph">
<p>假设我们需要在 Elasticsearch 中存储一个页面访问量计数器。
每当有用户浏览网页，我们对该页面的计数器进行累加。但是，如果它是一个新网页，我们不能确定计数器已经存在。
如果我们尝试更新一个不存在的文档，那么更新操作将会失败。</p>
</div>
<div class="paragraph">
<p>在这样的情况下，我们可以使用 <code>upsert</code> 参数，指定如果文档不存在就应该先创建它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/pageviews/1/_update
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 1
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们第一次运行这个请求时， <code>upsert</code> 值作为新文档被索引，初始化 <code>views</code> 字段为 <code>1</code> 。
在后续的运行中，由于文档已经存在， <code>script</code> 更新操作将替代 <code>upsert</code> 进行应用，对 <code>views</code> 计数器进行累加。</p>
</div>
</div>
<div class="sect3">
<h4 id="_Updates_and_Conflicts">更新和冲突</h4>
<div class="paragraph">
<p>在本节的介绍中，我们说明 <em>检索</em> 和 <em>重建索引</em> 步骤的间隔越小，变更冲突的机会越小。
但是它并不能完全消除冲突的可能性。 还是有可能在 <code>update</code> 设法重新索引之前，来自另一进程的请求修改了文档。</p>
</div>
<div class="paragraph">
<p>为了避免数据丢失， <code>update</code> API 在 <em>检索</em> 步骤时检索得到文档当前的 <code><em>version</code> 号，并传递版本号到 _重建索引</em> 步骤的 <code>index</code> 请求。
如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 <code>_version</code> 号将不匹配，更新请求将会失败。</p>
</div>
<div class="paragraph">
<p>对于部分更新的很多使用场景，文档已经被改变也没有关系。
例如，如果两个进程都对页面访问量计数器进行递增操作，它们发生的先后顺序其实不太重要；
如果冲突发生了，我们唯一需要做的就是尝试再次更新。</p>
</div>
<div class="paragraph">
<p>这可以通过设置参数 <code>retry_on_conflict</code> 来自动完成，
这个参数规定了失败之前 <code>update</code> 应该重试的次数，它的默认值为 <code>0</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/pageviews/1/_update?retry_on_conflict=5 <b class="conum">(1)</b>
{
   "script" : "ctx._source.views+=1",
   "upsert": {
       "views": 0
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>失败之前重试该更新5次。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在增量操作无关顺序的场景，例如递增计数器等这个方法十分有效，但是在其他情况下变更的顺序 <em>是</em> 非常重要的。
类似 <a href="#index-doc"><code>index</code> API</a> ， <code>update</code> API 默认采用 <em>最终写入生效</em> 的方案，但它也接受一个 <code>version</code> 参数来允许你使用 <a href="#optimistic-concurrency-control">optimistic concurrency control</a> 指定想要更新文档的版本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Retrieving_Multiple_Documents">取回多个文档</h3>
<div class="paragraph">
<p>Elasticsearch 的速度已经很快了，但甚至能更快。
将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。
如果你需要从 Elasticsearch 检索很多文档，那么使用 <em>multi-get</em> 或者 <code>mget</code> API
来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p>
</div>
<div class="paragraph">
<p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个元素包含需要检索文档的元数据，
包括 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该响应体也包含一个 <code>docs</code> 数组，
对于每一个在请求中指定的文档，这个数组中都包含有一个对应的响应，且顺序与请求中的顺序相同。
其中的每一个响应都和使用单个 <a href="#get-doc"><code>get</code> request</a> 请求所得到的响应体相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果想检索的数据都在相同的 <code>_index</code> 中（甚至相同的 <code>_type</code> 中），则可以在 URL 中指定默认的 <code>/_index</code> 或者默认的  <code>/_index/_type</code> 。</p>
</div>
<div class="paragraph">
<p>你仍然可以通过单独请求覆盖这些值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，如果所有文档的 <code>_index</code> 和 <code>_type</code> 都是相同的，你可以只传一个 <code>ids</code> 数组，而不是整个 <code>docs</code> 数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，我们请求的第二个文档是不存在的。我们指定类型为 <code>blog</code> ，但是文档 ID <code>1</code> 的类型是 <code>pageviews</code> ，这个不存在的情况将在响应体中被报告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <b class="conum">(1)</b>
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>未找到该文档。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>事实上第二个文档未能找到并不妨碍第一个文档被检索到。每个文档都是单独检索和报告的。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 <code>200</code> 。事实上，即使请求 <em>没有</em> 找到任何文档，它的状态码依然是 <code>200</code>
--因为 <code>mget</code> 请求本身已经成功执行。
为了确定某个文档查找是成功或者失败，你需要检查 <code>found</code> 标记。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="bulk">代价较小的批量操作</h3>
<div class="paragraph">
<p>与 <code>mget</code> 可以使我们一次取回多个文档同样的方式，
<code>bulk</code> API 允许在单个步骤中进行多次 <code>create</code> 、 <code>index</code> 、 <code>update</code> 或 <code>delete</code> 请求。
如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p>
</div>
<div class="paragraph">
<p><code>bulk</code> 与其他的请求体格式稍有不同，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ action: { metadata }}\n
{ request body        }\n
{ action: { metadata }}\n
{ request body        }\n
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种格式类似一个有效的单行 JSON 文档 <em>流</em> ，它通过换行符(<code>\n</code>)连接到一起。注意两个要点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每行一定要以换行符(<code>\n</code>)结尾， <em>包括最后一行</em> 。这些换行符被用作一个标记，可以有效分隔行。</p>
</li>
<li>
<p>这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。这意味着这个 JSON <em>不</em> 能使用 pretty 参数打印。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
在 <a href="#bulk-format">为什么是有趣的格式？</a> 中， 我们解释为什么 <code>bulk</code> API 使用这种格式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>action/metadata 行指定 <em>哪一个文档</em> 做 <em>什么操作</em> 。</p>
</div>
<div class="paragraph">
<p>action 必须是以下选项之一:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>create</code></dt>
<dd>
<p>如果文档不存在，那么就创建它。详情请见 <a href="#create-doc">创建新文档</a>。</p>
</dd>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>创建一个新文档或者替换一个现有的文档。详情请见 <a href="#index-doc">索引文档</a> 和 <a href="#update-doc">更新整个文档</a>。</p>
</dd>
<dt class="hdlist1"><code>update</code></dt>
<dd>
<p>部分更新一个文档。详情请见 <a href="#partial-updates">文档的部分更新</a>。</p>
</dd>
<dt class="hdlist1"><code>delete</code></dt>
<dd>
<p>删除一个文档。详情请见 <a href="#delete-doc">删除文档</a>。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>metadata 应该指定被索引、创建、更新或者删除的文档的 <code>_index</code> 、 <code>_type</code> 和 <code>_id</code> 。</p>
</div>
<div class="paragraph">
<p>例如，一个 <code>delete</code> 请求看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>request body 行由文档的 <code>_source</code> 本身组成&#8212;&#8203;文档包含的字段和值。它是 <code>index</code> 和 <code>create</code> 操作所必需的，这是有道理的：你必须提供文档以索引。</p>
</div>
<div class="paragraph">
<p>它也是 <code>update</code> 操作所必需的，并且应该包含你传递给 <code>update</code> API 的相同请求体： <code>doc</code> 、 <code>upsert</code> 、 <code>script</code> 等等。
删除操作不需要 request body 行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "create":  { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不指定 <code>_id</code> ，将会自动生成一个 ID ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "index": { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了把所有的操作组合在一起，一个完整的 <code>bulk</code> 请求 有以下形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_bulk
{ "delete": { "_index": "website", "_type": "blog", "_id": "123" }} <b class="conum">(1)</b>
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "My first blog post" }
{ "index":  { "_index": "website", "_type": "blog" }}
{ "title":    "My second blog post" }
{ "update": { "_index": "website", "_type": "blog", "_id": "123", "_retry_on_conflict" : 3} }
{ "doc" : {"title" : "My updated blog post"} } <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>请注意 <code>delete</code> 动作不能有请求体,它后面跟着的是另外一个操作。</p>
</li>
<li>
<p>谨记最后一个换行符不要落下。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这个 Elasticsearch 响应包含 <code>items</code> 数组，这个数组的内容是以请求的顺序列出来的每个请求的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "took": 4,
   "errors": false, <b class="conum">(1)</b>
   "items": [
      {  "delete": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 2,
            "status":   200,
            "found":    true
      }},
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 3,
            "status":   201
      }},
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "EiwfApScQiiy7TIKFxRCTw",
            "_version": 1,
            "status":   201
      }},
      {  "update": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 4,
            "status":   200
      }}
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>所有的子请求都成功完成。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。
如果其中任何子请求失败，最顶层的 <code>error</code> 标志被设置为 <code>true</code> ，并且在相应的请求报告出错误明细：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_bulk
{ "create": { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "Cannot create - it already exists" }
{ "index":  { "_index": "website", "_type": "blog", "_id": "123" }}
{ "title":    "But we can update it" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在响应中，我们看到 <code>create</code> 文档  <code>123</code> 失败，因为它已经存在。但是随后的 <code>index</code> 请求，也是对文档 <code>123</code> 操作，就成功了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "took": 3,
   "errors": true, <b class="conum">(1)</b>
   "items": [
      {  "create": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "status":   409, <b class="conum">(2)</b>
            "error":    "DocumentAlreadyExistsException <b class="conum">(3)</b>
                        [[website][4] [blog][123]:
                        document already exists]"
      }},
      {  "index": {
            "_index":   "website",
            "_type":    "blog",
            "_id":      "123",
            "_version": 5,
            "status":   200 <b class="conum">(4)</b>
      }}
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>一个或者多个请求失败。</p>
</li>
<li>
<p>这个请求的HTTP状态码报告为 <code>409 CONFLICT</code> 。</p>
</li>
<li>
<p>解释为什么请求失败的错误信息。</p>
</li>
<li>
<p>第二个请求成功，返回 HTTP 状态码 <code>200 OK</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这也意味着 <code>bulk</code> 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。</p>
</div>
<div class="sect3">
<h4 id="_Dont_Repeat_Yourself">不要重复指定Index和Type</h4>
<div class="paragraph">
<p>也许你正在批量索引日志数据到相同的 <code>index</code> 和 <code>type</code> 中。 
但为每一个文档指定相同的元数据是一种浪费。相反，可以像 <code>mget</code> API 一样，在 <code>bulk</code> 请求的 URL 中接收默认的 <code>/_index</code> 或者 <code>/_index/_type</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/_bulk
{ "index": { "_type": "log" }}
{ "event": "User logged in" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你仍然可以覆盖元数据行中的 <code>_index</code> 和 <code>_type</code> , 但是它将使用 URL 中的这些元数据值作为默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /website/log/_bulk
{ "index": {}}
{ "event": "User logged in" }
{ "index": { "_type": "blog" }}
{ "title": "Overriding the default type" }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_How_Big_Is_Too_Big">多大是太大了？</h4>
<div class="paragraph">
<p>整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。
 批量请求的大小有一个最佳值，大于这个值，性能将不再提升，甚至会下降。
但是最佳值不是一个固定的值。它完全取决于硬件、文档的大小和复杂度、索引和搜索的负载的整体情况。</p>
</div>
<div class="paragraph">
<p>幸运的是，很容易找到这个 <em>最佳点</em> ：通过批量索引典型文档，并不断增加批量大小进行尝试。
当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。</p>
</div>
<div class="paragraph">
<p>密切关注你的批量请求的物理大小往往非常有用，一千个 1KB 的文档是完全不同于一千个 1MB 文档所占的物理大小。
一个好的批量大小在开始处理后所占用的物理大小约为 5-15 MB。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-docs">分布式文档存储</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前面的章节，我们介绍了如何索引和查询数据，不过我们忽略了很多底层的技术细节，
例如文件是如何分布到集群的，又是如何从集群中获取的。
Elasticsearch 本意就是隐藏这些底层细节，让我们好专注在业务开发中，所以其实你不必了解这么深入也无妨。</p>
</div>
<div class="paragraph">
<p>在这个章节中，我们将深入探索这些核心的技术细节，这能帮助你更好地理解数据如何被存储到这个分布式系统中。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">注意</div>
<div class="paragraph">
<p>这个章节包含了一些高级话题，上面也提到过，就算你不记住和理解所有的细节仍然能正常使用 Elasticsearch。
如果你有兴趣的话，这个章节可以作为你的课外兴趣读物，扩展你的知识面。</p>
</div>
<div class="paragraph">
<p>如果你在阅读这个章节的时候感到很吃力，也不用担心。
这个章节仅仅只是用来告诉你 Elasticsearch 是如何工作的，
将来在工作中如果你需要用到这个章节提供的知识，可以再回过头来翻阅。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="routing-value">路由一个文档到一个分片中</h3>
<div class="paragraph">
<p>当索引一个文档的时候，文档会被存储到一个主分片中。  Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 <code>1</code> 还是分片 <code>2</code> 中呢？</p>
</div>
<div class="paragraph">
<p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>shard = hash(routing) % number_of_primary_shards</pre>
</div>
</div>
<div class="paragraph">
<p><code>routing</code> 是一个可变值，默认是文档的 <code>_id</code> ，也可以设置成一个自定义的值。 <code>routing</code> 通过 hash 函数生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code> （主分片的数量）后得到 <strong>余数</strong> 。这个分布在 <code>0</code> 到 <code>number_of_primary_shards-1</code> 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
</div>
<div class="paragraph">
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量  并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>你可能觉得由于 Elasticsearch 主分片数量是固定的会使索引难以进行扩容。实际上当你需要时有很多技巧可以轻松实现扩容。我们将会在<a href="#scale">[scale]</a>一章中提到更多有关水平扩展的内容。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>所有的文档 API（ <code>get</code> 、 <code>index</code> 、 <code>delete</code> 、 <code>bulk</code> 、 <code>update</code> 以及 <code>mget</code> ）都接受一个叫做 <code>routing</code> 的路由参数  ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中。我们也会在<a href="#scale">[scale]</a>这一章中详细讨论为什么会有这样一种需求。</p>
</div>
</div>
<div class="sect2">
<h3 id="how-primary-and-replica-shards-interact">主分片和副本分片如何交互</h3>
<div class="paragraph">
<p>为了说明目的, 我们 假设有一个集群由三个节点组成。
它包含一个叫 <code>blogs</code> 的索引，有两个主分片，每个主分片有两个副本分片。相同分片的副本不会放在同一节点，所以我们的集群看起来像 <a href="#img-distrib">有三个节点和一个索引的集群</a>。</p>
</div>
<div id="img-distrib" class="imageblock">
<div class="content">
<img src="images/elas_0401.png" alt="有三个节点和一个索引的集群">
</div>
<div class="title">Figure 8. 有三个节点和一个索引的集群</div>
</div>
<div class="paragraph">
<p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。
每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。
在下面的例子中，将所有的请求发送到 <code>Node 1</code> ，我们将其称为 <em>协调节点(coordinating node)</em> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="distrib-write">新建、索引和删除文档</h3>
<div class="paragraph">
<p>新建、索引和删除 请求都是 <em>写</em> 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示 <a href="#img-distrib-write">新建、索引和删除单个文档</a>.</p>
</div>
<div id="img-distrib-write" class="imageblock">
<div class="content">
<img src="images/elas_0402.png" alt="新建、索引和删除单个文档">
</div>
<div class="title">Figure 9. 新建、索引和删除单个文档</div>
</div>
<div class="paragraph">
<p>以下是在主副分片和任何副本分片上面 
成功新建，索引和删除文档所需要的步骤顺序：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端向 <code>Node 1</code> 发送新建、索引或者删除请求。</p>
</li>
<li>
<p>节点使用文档的 <code>_id</code> 确定文档属于分片 0 。请求会被转发到 <code>Node 3</code>，因为分片 0 的主分片目前被分配在 <code>Node 3</code> 上。</p>
</li>
<li>
<p><code>Node 3</code> 在主分片上面执行请求。如果成功了，它将请求并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 的副本分片上。一旦所有的副本分片都报告成功, <code>Node 3</code> 将向协调节点报告成功，协调节点向客户端报告成功。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。</p>
</div>
<div class="paragraph">
<p>有一些可选的请求参数允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为Elasticsearch已经很快，但是为了完整起见，在这里阐述如下：</p>
</div>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>consistency</code></dt>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>consistency，即一致性。在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 <em>规定数量(quorum)</em>（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写_操作(其中分片副本可以是主分片或者副本分片)。这是为了避免在发生网络分区故障（network partition）的时候进行_写_操作，进而导致数据不一致。_规定数量_即：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int( (primary + number_of_replicas) / 2 ) + 1</pre>
</div>
</div>
<div class="paragraph">
<p><code>consistency</code> 参数的值可以设为 <code>one</code> （只要主分片状态 ok 就允许执行_写_操作）,<code>all</code>（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作）, 或 <code>quorum</code> 。默认值为 <code>quorum</code> , 即大多数的分片副本状态没问题就允许执行_写_操作。</p>
</div>
<div class="paragraph">
<p>注意，<em>规定数量</em> 的计算公式中 <code>number_of_replicas</code> 指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有三个副本分片，那规定数量的计算结果即：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int( (primary + 3 replicas) / 2 ) + 1 = 3</pre>
</div>
</div>
<div class="paragraph">
<p>如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。</p>
</div>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<p>如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。
如果你需要，你可以使用 <code>timeout</code> 参数 使它更早终止： <code>100</code> 100毫秒，<code>30s</code> 是30秒。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>新索引默认有 <code>1</code> 个副本分片，这意味着为满足 <code>规定数量</code> <em>应该</em> 需要两个活动的分片副本。
但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当 <code>number_of_replicas</code> 大于1的时候，规定数量才会执行。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="distrib-read">取回一个文档</h3>
<div class="paragraph">
<p>可以从主分片或者从其它任意副本分片检索文档 ，如下图所示 <a href="#img-distrib-read">取回单个文档</a>.</p>
</div>
<div id="img-distrib-read" class="imageblock">
<div class="content">
<img src="images/elas_0403.png" alt="取回单个文档">
</div>
<div class="title">Figure 10. 取回单个文档</div>
</div>
<div class="paragraph">
<p>以下是从主分片或者副本分片检索文档的步骤顺序：</p>
</div>
<div class="paragraph">
<p>1、客户端向 <code>Node 1</code> 发送获取请求。</p>
</div>
<div class="paragraph">
<p>2、节点使用文档的 <code>_id</code> 来确定文档属于分片 <code>0</code> 。分片 <code>0</code> 的副本分片存在于所有的三个节点上。
   在这种情况下，它将请求转发到 <code>Node 2</code> 。</p>
</div>
<div class="paragraph">
<p>3、<code>Node 2</code> 将文档返回给 <code>Node 1</code> ，然后将文档返回给客户端。</p>
</div>
<div class="paragraph">
<p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p>
</div>
<div class="paragraph">
<p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。
在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。
一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_partial_updates_to_a_document">局部更新文档</h3>
<div class="paragraph">
<p>如 <a href="#img-distrib-update">局部更新文档</a> 所示，<code>update</code> API 结合了先前说明的读取和写入模式。</p>
</div>
<div id="img-distrib-update" class="imageblock">
<div class="content">
<img src="images/elas_0404.png" alt="局部更新文档">
</div>
<div class="title">Figure 11. 局部更新文档</div>
</div>
<div class="paragraph">
<p>以下是部分更新一个文档的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端向 <code>Node 1</code> 发送更新请求。</p>
</li>
<li>
<p>它将请求转发到主分片所在的 <code>Node 3</code> 。</p>
</li>
<li>
<p><code>Node 3</code> 从主分片检索文档，修改 <code>_source</code> 字段中的 JSON ，并且尝试重新索引主分片的文档。
如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 <code>retry_on_conflict</code> 次后放弃。</p>
</li>
<li>
<p>如果 <code>Node 3</code> 成功地更新文档，它将新版本的文档并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 上的副本分片，重新建立索引。
一旦所有副本分片都返回成功， <code>Node 3</code> 向协调节点也返回成功，协调节点向客户端返回成功。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>update</code> API 还接受在 <a href="#distrib-write">新建、索引和删除文档</a> 章节中介绍的 <code>routing</code> 、 <code>replication</code> 、 <code>consistency</code> 和 <code>timeout</code> 参数。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">基于文档的复制</div>
<div class="paragraph">
<p>当主分片把更改转发到副本分片时， 它不会转发更新请求。
相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。
如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="distrib-multi-doc">多文档模式</h3>
<div class="paragraph">
<p><code>mget</code> 和 <code>bulk</code> API 的模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。
它将整个多文档请求分解成 <em>每个分片</em> 的多文档请求，并且将这些请求并行转发到每个参与节点。</p>
</div>
<div class="paragraph">
<p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端，如 <a href="#img-distrib-mget">使用 <code>mget</code> 取回多个文档</a> 所示。</p>
</div>
<div id="img-distrib-mget" class="imageblock">
<div class="content">
<img src="images/elas_0405.png" alt="“使用 `mget` 取回多个文档”">
</div>
<div class="title">Figure 12. 使用 <code>mget</code> 取回多个文档</div>
</div>
<div class="paragraph">
<p>以下是使用单个 <code>mget</code> 请求取回多个文档所需的步骤顺序：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端向 <code>Node 1</code> 发送 <code>mget</code> 请求。</p>
</li>
<li>
<p><code>Node 1</code> 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， <code>Node 1</code> 构建响应并将其返回给客户端。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>可以对 <code>docs</code> 数组中每个文档设置 <code>routing</code> 参数。</p>
</div>
<div class="paragraph">
<p>bulk API， 如 <a href="#img-distrib-bulk">使用 <code>bulk</code> 修改多个文档</a> 所示， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。</p>
</div>
<div id="img-distrib-bulk" class="imageblock">
<div class="content">
<img src="images/elas_0406.png" alt="“使用 `bulk` 修改多个文档”">
</div>
<div class="title">Figure 13. 使用 <code>bulk</code> 修改多个文档</div>
</div>
<div class="paragraph">
<p><code>bulk</code> API 按如下步骤顺序执行：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端向 <code>Node 1</code> 发送 <code>bulk</code> 请求。</p>
</li>
<li>
<p><code>Node 1</code> 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</p>
</li>
<li>
<p>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。
一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>bulk</code> API 还可以在整个批量请求的最顶层使用 <code>consistency</code> 参数，以及在每个请求中的元数据中使用 <code>routing</code> 参数。</p>
</div>
<div class="sect3 pagebreak-before">
<h4 id="bulk-format">为什么是有趣的格式？</h4>
<div class="paragraph">
<p>当我们早些时候在<a href="#bulk">代价较小的批量操作</a>章节了解批量请求时，您可能会问自己，
  "为什么 <code>bulk</code> API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 <code>mget</code> API？" 。</p>
</div>
<div class="paragraph">
<p>为了回答这一点，我们需要解释一点背景：在批量请求中引用的每个文档可能属于不同的主分片，
每个文档可能被分配给集群中的任何节点。这意味着批量请求 <code>bulk</code> 中的每个 <em>操作</em> 都需要被转发到正确节点上的正确分片。</p>
</div>
<div class="paragraph">
<p>如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 JSON 解析为数组（包括文档数据，可以非常大）</p>
</li>
<li>
<p>查看每个请求以确定应该去哪个分片</p>
</li>
<li>
<p>为每个分片创建一个请求数组</p>
</li>
<li>
<p>将这些数组序列化为内部传输格式</p>
</li>
<li>
<p>将请求发送到每个分片</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收。</p>
</div>
<div class="paragraph">
<p>相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。
它使用换行符字符来识别和解析小的 action/metadata 行来决定哪个分片应该处理每个请求。</p>
</div>
<div class="paragraph">
<p>这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search">搜索——最基本的工具</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，我们已经学会了如何使用 Elasticsearch 作为一个简单的 NoSQL 风格的分布式文档存储系统。我们可以将一个 JSON 文档扔到 Elasticsearch 里，然后根据 ID 检索。但 Elasticsearch 真正强大之处在于可以从无规律的数据中找出有意义的信息——从“大数据”到“大信息”。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 不只会_存储（stores）_ 文档，为了能被搜索到也会为文档添加_索引（indexes）_ ，这也是为什么我们使用结构化的 JSON 文档，而不是无结构的二进制数据。</p>
</div>
<div class="paragraph">
<p><em>文档中的每个字段都将被索引并且可以被查询</em> 。不仅如此，在简单查询时，Elasticsearch 可以使用 <em>所有（all）</em> 这些索引字段，以惊人的速度返回结果。这是你永远不会考虑用传统数据库去做的一些事情。</p>
</div>
<div class="paragraph">
<p><em>搜索（search）</em> 可以做到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在类似于 <code>gender</code> 或者 <code>age</code> 这样的字段上使用结构化查询，<code>join_date</code> 这样的字段上使用排序，就像SQL的结构化查询一样。</p>
</li>
<li>
<p>全文检索，找出所有匹配关键字的文档并按照_相关性（relevance）_ 排序后返回结果。</p>
</li>
<li>
<p>以上二者兼而有之。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>很多搜索都是开箱即用的，为了充分挖掘 Elasticsearch 的潜力，你需要理解以下三个概念：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>映射（Mapping）</em> </dt>
<dd>
<p>描述数据在每个字段内如何存储</p>
</dd>
<dt class="hdlist1"><em>分析（Analysis）</em> </dt>
<dd>
<p>全文是如何处理使之可以被搜索的</p>
</dd>
<dt class="hdlist1"><em>领域特定查询语言（Query DSL）</em> </dt>
<dd>
<p>Elasticsearch 中强大灵活的查询语言</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以上提到的每个点都是一个大话题，我们将在 <a href="#search-in-depth">[search-in-depth]</a> 一章详细阐述它们。本章节我们将介绍这三点的一些基本概念——仅仅帮助你大致了解搜索是如何工作的。</p>
</div>
<div class="paragraph">
<p>我们将使用最简单的形式开始介绍 <code>search</code> API。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">测试数据</div>
<div class="paragraph">
<p>本章节的测试数据可以在这里找到： <a href="https://gist.github.com/clintongormley/8579281" class="bare">https://gist.github.com/clintongormley/8579281</a> 。</p>
</div>
<div class="paragraph">
<p>你可以把这些命令复制到终端中执行来实践本章的例子。</p>
</div>
<div class="paragraph">
<p>另外，如果你读的是在线版本，可以 <a href="sense_widget.html?snippets/050_Search/Test_data.json">点击这个链接</a> 感受下。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="empty-search">空搜索</h3>
<div class="paragraph">
<p>搜索API的最基础的形式是没有指定任何查询的空搜索，它简单地返回集群中所有索引下的所有文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的结果（为了界面简洁编辑过的）像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "hits" : {
      "total" :       14,
      "hits" : [
        {
          "_index":   "us",
          "_type":    "tweet",
          "_id":      "7",
          "_score":   1,
          "_source": {
             "date":    "2014-09-17",
             "name":    "John Smith",
             "tweet":   "The Query DSL is really powerful and flexible",
             "user_id": 2
          }
       },
        ... 9 RESULTS REMOVED ...
      ],
      "max_score" :   1
   },
   "took" :           4,
   "_shards" : {
      "failed" :      0,
      "successful" :  10,
      "total" :       10
   },
   "timed_out" :      false
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_hits">hits</h4>
<div class="paragraph">
<p>返回结果中最重要的部分是 <code>hits</code> ，它包含 <code>total</code> 字段来表示匹配到的文档总数，并且一个 <code>hits</code> 数组包含所查询结果的前十个文档。</p>
</div>
<div class="paragraph">
<p>在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。</p>
</div>
<div class="paragraph">
<p>每个结果还有一个 <code>_score</code>  ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 <code>_score</code> 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 <code>1</code> 是中性的 <code>_score</code> 。</p>
</div>
<div class="paragraph">
<p><code>max_score</code> 值是与查询所匹配文档的 <code>_score</code> 的最大值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_took">took</h4>
<div class="paragraph">
<p><code>took</code> 值告诉我们执行整个搜索请求耗费了多少毫秒。</p>
</div>
</div>
<div class="sect3">
<h4 id="_shards">shards</h4>
<div class="paragraph">
<p><code>_shards</code> 部分告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_timeout">timeout</h4>
<div class="paragraph">
<p><code>timed_out</code> 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。如果低响应时间比完成结果更重要，你可以指定 <code>timeout</code> 为 10 或者 10ms（10毫秒），或者 1s（1秒）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?timeout=10ms</code></pre>
</div>
</div>
<div class="paragraph">
<p>在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>应当注意的是 <code>timeout</code> 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。</p>
</div>
<div class="paragraph">
<p>使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multi-index-multi-type">多索引，多类型</h3>
<div class="paragraph">
<p>你有没有注意到之前的 <a href="#empty-search">empty search</a> 的结果，不同类型的文档&#x2014; <code>user</code> 和 <code>tweet</code> 来自不同的索引&#x2014; <code>us</code> 和 <code>gb</code> ？</p>
</div>
<div class="paragraph">
<p>如果不对某一特殊的索引或者类型做限制，就会搜索集群中的所有文档。Elasticsearch 转发搜索请求到每一个主分片或者副本分片，汇集查询出的前10个结果，并且返回给我们。</p>
</div>
<div class="paragraph">
<p>然而，经常的情况下，你想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>/_search</code></dt>
<dd>
<p>在所有的索引中搜索所有的类型</p>
</dd>
<dt class="hdlist1"><code>/gb/_search</code></dt>
<dd>
<p>在 <code>gb</code> 索引中搜索所有的类型</p>
</dd>
<dt class="hdlist1"><code>/gb,us/_search</code></dt>
<dd>
<p>在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档</p>
</dd>
<dt class="hdlist1"><code>/g*,u*/_search</code></dt>
<dd>
<p>在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型</p>
</dd>
<dt class="hdlist1"><code>/gb/user/_search</code></dt>
<dd>
<p>在 <code>gb</code> 索引中搜索 <code>user</code> 类型</p>
</dd>
<dt class="hdlist1"><code>/gb,us/user,tweet/_search</code></dt>
<dd>
<p>在 <code>gb</code> 和 <code>us</code> 索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p>
</dd>
<dt class="hdlist1"><code>/_all/user,tweet/_search</code></dt>
<dd>
<p>在所有的索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的&#8212;&#8203;只是会涉及到更多的分片。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>接下来，你将明白这种简单的方式如何灵活的根据需求的变化让扩容变得简单。</p>
</div>
</div>
<div class="sect2">
<h3 id="pagination">分页</h3>
<div class="paragraph">
<p>在之前的 <a href="#empty-search">空搜索</a> 中说明了集群中有 14 个文档匹配了（empty）query 。
但是在 <code>hits</code> 数组中只有 10 个文档。如何才能看到其他的文档？</p>
</div>
<div class="paragraph">
<p>和 SQL 使用 <code>LIMIT</code> 关键字返回单个 <code>page</code> 结果的方法相同，Elasticsearch 接受 <code>from</code> 和 <code>size</code> 参数：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>size</code></dt>
<dd>
<p>显示应该返回的结果数量，默认是 <code>10</code></p>
</dd>
<dt class="hdlist1"><code>from</code></dt>
<dd>
<p>显示应该跳过的初始结果数量，默认是 <code>0</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?size=5
GET /_search?size=5&amp;from=5
GET /_search?size=5&amp;from=10</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。
但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行集中排序以保证整体顺序是正确的。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">在分布式系统中深度分页</div>
<div class="paragraph">
<p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。
当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 <em>协调节点</em> ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p>
</div>
<div class="paragraph">
<p>现在假设我们请求第 1000 页&#8212;&#8203;结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。
然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p>
</div>
<div class="paragraph">
<p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
在 <a href="#reindex">重新索引你的数据</a> 中解释了如何 <em>能够</em> 有效获取大量的文档。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="search-lite"><em>轻量</em> 搜索</h3>
<div class="paragraph">
<p>有两种形式的 <code>搜索</code> API：一种是 ``轻量的'' <em>查询字符串</em> 版本，要求在查询字符串中传递所有的参数，另一种是更完整的 <em>请求体</em> 版本，要求使用 JSON 格式和更丰富的查询表达式作为搜索语言。</p>
</div>
<div class="paragraph">
<p>查询字符串搜索非常适用于通过命令行做即席查询。例如，查询在 <code>tweet</code> 类型中 <code>tweet</code> 字段包含 <code>elasticsearch</code> 单词的所有文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_all/tweet/_search?q=tweet:elasticsearch</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个查询在 <code>name</code> 字段中包含 <code>john</code> 并且在 <code>tweet</code> 字段中包含 <code>mary</code> 的文档。实际的查询就是这样</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+name:john +tweet:mary</pre>
</div>
</div>
<div class="paragraph">
<p>但是查询字符串参数所需要的 <em>百分比编码</em> （译者注：URL编码）实际上更加难懂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>+</code> 前缀表示必须与查询条件匹配。类似地， <code>-</code> 前缀表示一定不与查询条件匹配。没有 <code>+</code> 或者 <code>-</code> 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p>
</div>
<div class="sect3">
<h4 id="all-field-intro">_all 字段</h4>
<div class="paragraph">
<p>这个简单搜索返回包含 <code>mary</code> 的所有文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?q=mary</code></pre>
</div>
</div>
<div class="paragraph">
<p>之前的例子中，我们在 <code>tweet</code> 和 <code>name</code> 字段中搜索内容。然而，这个查询的结果在三个地方提到了 <code>mary</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有一个用户叫做 Mary</p>
</li>
<li>
<p>6条微博发自 Mary</p>
</li>
<li>
<p>一条微博直接 @mary</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Elasticsearch 是如何在三个不同的字段中查找到结果的呢？</p>
</div>
<div class="paragraph">
<p>当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 <code>_all</code> 字段进行索引。例如，当索引这个文档时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "tweet":    "However did I manage before Elasticsearch?",
    "date":     "2014-09-14",
    "name":     "Mary Jones",
    "user_id":  1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就好似增加了一个名叫 <code>_all</code> 的额外字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非设置特定字段，否则查询字符串就使用 <code>_all</code> 字段进行搜索。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
在刚开始开发一个应用时，<code>_all</code> 字段是一个很实用的特性。之后，你会发现如果搜索时用指定字段来代替 <code>_all</code> 字段，将会更好控制搜索结果。当 <code>_all</code> 字段不再有用的时候，可以将它置为失效，正如在 <a href="#all-field">元数据: _all 字段</a> 中所解释的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 pagebreak-before">
<h4 id="query-string-query">更复杂的查询</h4>
<div class="paragraph">
<p>下面的查询针对tweents类型，并使用以下的条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code> 字段中包含 <code>mary</code> 或者 <code>john</code></p>
</li>
<li>
<p><code>date</code> 值大于 <code>2014-09-10</code></p>
</li>
<li>
<p><code><em>all</em></code> 字段包含 <code>aggregations</code> 或者 <code>geo</code></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询字符串在做了适当的编码后，可读性很差：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</code></pre>
</div>
</div>
<div class="paragraph">
<p>从之前的例子中可以看出，这种 <em>轻量</em> 的查询字符串搜索效果还是挺让人惊喜的。 它的查询语法在相关参考文档中有详细解释，以便简洁的表达很复杂的查询。对于通过命令做一次性查询，或者是在开发阶段，都非常方便。</p>
</div>
<div class="paragraph">
<p>但同时也可以看到，这种精简让调试更加晦涩和困难。而且很脆弱，一些查询字符串中很小的语法错误，像 <code>-</code> ， <code>:</code> ， <code>/</code> 或者 <code>"</code> 不匹配等，将会返回错误而不是搜索结果。</p>
</div>
<div class="paragraph">
<p>最后，查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>因为这些原因，不推荐直接向用户暴露查询字符串搜索功能，除非对于集群和数据来说非常信任他们。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>相反，我们经常在生产环境中更多地使用功能全面的 <em>request body</em> 查询API，除了能完成以上所有功能，还有一些附加功能。但在到达那个阶段之前，首先需要了解数据在 Elasticsearch 中是如何被索引的。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mapping-analysis">映射和分析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当摆弄索引里面的数据时，我们发现一些奇怪的事情。一些事情看起来被打乱了：在我们的索引中有12条推文，其中只有一条包含日期 <code>2014-09-15</code> ，但是看一看下面查询命中的 <code>总数</code> （total）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?q=2014              # 12 results
GET /_search?q=2014-09-15        # 12 results !
GET /_search?q=date:2014-09-15   # 1  result
GET /_search?q=date:2014         # 0  results !</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么在 <a href="#all-field-intro"><code>_all</code> </a> 字段查询日期返回所有推文，而在 <code>date</code> 字段只查询年份却没有返回结果？为什么我们在 <code>_all</code> 字段和 <code>date</code> 字段的查询结果有差别？</p>
</div>
<div class="paragraph">
<p>推测起来，这是因为数据在 <code><em>all</code> 字段与 <code>date</code> 字段的索引方式不同。所以，通过请求 <code>gb</code> 索引中 <code>tweet</code> 类型的_映射</em>（或模式定义），让我们看一看 Elasticsearch 是如何解释我们文档结构的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /gb/_mapping/tweet</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将得到如下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "gb": {
      "mappings": {
         "tweet": {
            "properties": {
               "date": {
                  "type": "date",
                  "format": "strict_date_optional_time||epoch_millis"
               },
               "name": {
                  "type": "string"
               },
               "tweet": {
                  "type": "string"
               },
               "user_id": {
                  "type": "long"
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>基于对字段类型的猜测， Elasticsearch 动态为我们产生了一个映射。这个响应告诉我们 <code>date</code> 字段被认为是 <code>date</code> 类型的。由于 <code>_all</code> 是默认字段，所以没有提及它。但是我们知道 <code>_all</code> 字段是 <code>string</code> 类型的。</p>
</div>
<div class="paragraph">
<p>所以 <code>date</code> 字段和 <code>string</code> 字段索引方式不同，因此搜索结果也不一样。这完全不令人吃惊。你可能会认为核心数据类型 strings、numbers、Booleans 和 dates 的索引方式有稍许不同。没错，他们确实稍有不同。</p>
</div>
<div class="paragraph">
<p>但是，到目前为止，最大的差异在于代表 <em>精确值</em> （它包括 <code>string</code> 字段）的字段和代表 <em>全文</em> 的字段。这个区别非常重要——它将搜索引擎和所有其他数据库区别开来。</p>
</div>
<div class="sect2">
<h3 id="_exact_values_versus_full_text">精确值 VS 全文</h3>
<div class="paragraph">
<p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文。</p>
</div>
<div class="paragraph">
<p><em>精确值</em> 如它们听起来那样精确。例如日期或者用户 ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，<code>Foo</code> 和 <code>foo</code> 是不同的，<code>2014</code> 和 <code>2014-09-15</code> 也是不同的。</p>
</div>
<div class="paragraph">
<p>另一方面，<em>全文</em> 是指文本数据（通常以人类容易识别的语言书写），例如一个推文的内容或一封邮件的内容。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>全文通常是指非结构化的数据，但这里有一个误解：自然语言是高度结构化的。问题在于自然语言的规则是复杂的，导致计算机难以正确解析。例如，考虑这条语句：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>May is fun but June bores me.</pre>
</div>
</div>
<div class="paragraph">
<p>它指的是月份还是人？</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">WHERE name    = "John Smith"
  AND user_id = 2
  AND date    &gt; "2014-09-15"</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p>
</div>
<div class="paragraph">
<p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 <em>意图</em> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>搜索 <code>UK</code> ，会返回包含 <code>United Kindom</code> 的文档。</p>
</li>
<li>
<p>搜索 <code>jump</code> ，会匹配 <code>jumped</code> ， <code>jumps</code> ， <code>jumping</code> ，甚至是 <code>leap</code> 。</p>
</li>
<li>
<p>搜索 <code>johnny walker</code> 会匹配 <code>Johnnie Walker</code> ， <code>johnnie depp</code> 应该匹配 <code>Johnny Depp</code> 。</p>
</li>
<li>
<p><code>fox news hunting</code> 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， <code>fox hunting news</code> 应该返回关于猎狐的故事。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了促进这类在全文域中的查询，Elasticsearch 首先 <em>分析</em> 文档，之后根据结果创建 <em>倒排索引</em> 。在接下来的两节，我们会讨论倒排索引和分析过程。</p>
</div>
</div>
<div class="sect2">
<h3 id="inverted-index">倒排索引</h3>
<div class="paragraph">
<p>Elasticsearch 使用一种称为  <em>倒排索引</em> 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p>
</div>
<div class="paragraph">
<p>例如，假设我们有两个文档，每个文档的 <code>content</code> 域包含如下内容：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The quick brown fox jumped over the lazy dog</p>
</li>
<li>
<p>Quick brown foxes leap over lazy dogs in summer</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了创建倒排索引，我们首先将每个文档的 <code>content</code> 域拆分成单独的  词（我们称它为 <code>词条</code> 或 <code>tokens</code> ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term      Doc_1  Doc_2
-------------------------
Quick   |       |  X
The     |   X   |
brown   |   X   |  X
dog     |   X   |
dogs    |       |  X
fox     |   X   |
foxes   |       |  X
in      |       |  X
jumped  |   X   |
lazy    |   X   |  X
leap    |       |  X
over    |   X   |  X
quick   |   X   |
summer  |       |  X
the     |   X   |
------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term      Doc_1  Doc_2
-------------------------
brown   |   X   |  X
quick   |   X   |
------------------------
Total   |   2   |  1</pre>
</div>
</div>
<div class="paragraph">
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 <em>相似性算法</em>  ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p>
</div>
<div class="paragraph">
<p>但是，我们目前的倒排索引有一些问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Quick</code> 和 <code>quick</code> 以独立的词条出现，然而用户可能认为它们是相同的词。</p>
</li>
<li>
<p><code>fox</code> 和 <code>foxes</code> 非常相似, 就像 <code>dog</code> 和 <code>dogs</code> ；他们有相同的词根。</p>
</li>
<li>
<p><code>jumped</code> 和 <code>leap</code>, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用前面的索引搜索 <code>+Quick +fox</code> 不会得到任何匹配文档。（记住，<code>+</code> 前缀表明这个词必须存在。）只有同时出现 <code>Quick</code> 和 <code>fox</code> 的文档才满足这个查询条件，但是第一个文档包含 <code>quick fox</code> ，第二个文档包含 <code>Quick foxes</code> 。</p>
</div>
<div class="paragraph">
<p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p>
</div>
<div class="paragraph">
<p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Quick</code> 可以小写化为 <code>quick</code> 。</p>
</li>
<li>
<p><code>foxes</code> 可以 <em>词干提取</em> --变为词根的格式-- 为 <code>fox</code> 。类似的， <code>dogs</code> 可以为提取为 <code>dog</code> 。</p>
</li>
<li>
<p><code>jumped</code> 和 <code>leap</code> 是同义词，可以索引为相同的单词 <code>jump</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在索引看上去像这样：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term      Doc_1  Doc_2
-------------------------
brown   |   X   |  X
dog     |   X   |  X
fox     |   X   |  X
in      |       |  X
jump    |   X   |  X
lazy    |   X   |  X
over    |   X   |  X
quick   |   X   |  X
summer  |       |  X
the     |   X   |  X
------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>这还远远不够。我们搜索 <code>+Quick +fox</code> <em>仍然</em> 会失败，因为在我们的索引中，已经没有 <code>Quick</code> 了。但是，如果我们对搜索的字符串使用与 <code>content</code> 域相同的标准化规则，会变成查询 <code>+quick +fox</code> ，这样两个文档都会匹配！</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>分词和标准化的过程称为 <em>分析</em> ， 我们会在下个章节讨论。 </p>
</div>
</div>
<div class="sect2 pagebreak-before">
<h3 id="analysis-intro">分析与分析器</h3>
<div class="paragraph">
<p><em>分析</em> 包含下面的过程：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，将一块文本分成适合于倒排索引的独立的 <em>词条</em> ，</p>
</li>
<li>
<p>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 <em>recall</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>分析器执行上面的工作。 <em>分析器</em> 实际上是将三个功能封装到了一个包里：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">字符过滤器</dt>
<dd>
<p>首先，字符串按顺序通过每个 <em>字符过滤器</em> 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 <code>&amp;</code> 转化成 <code>and</code>。</p>
</dd>
<dt class="hdlist1">分词器</dt>
<dd>
<p>其次，字符串被 <em>分词器</em> 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</p>
</dd>
<dt class="hdlist1">Token 过滤器</dt>
<dd>
<p>最后，词条按顺序通过每个 <em>token 过滤器</em> 。这个过程可能会改变词条（例如，小写化 <code>Quick</code> ），删除词条（例如， 像 <code>a</code>， <code>and</code>， <code>the</code> 等无用词），或者增加词条（例如，像 <code>jump</code> 和 <code>leap</code> 这种同义词）。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。我们会在 <a href="#custom-analyzers">自定义分析器</a> 章节详细讨论。</p>
</div>
<div class="sect3">
<h4 id="_内置分析器">内置分析器</h4>
<div class="paragraph">
<p>但是， Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"Set the shape to semi-transparent by calling set_trans(5)"</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">标准分析器</dt>
<dd>
<p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 <a href="http://www.unicode.org/reports/tr29/">Unicode 联盟</a> 定义的 <em>单词边界</em> 划分文本。删除绝大部分标点。最后，将词条小写。它会产生</p>
<div class="literalblock">
<div class="content">
<pre>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</pre>
</div>
</div>
</dd>
<dt class="hdlist1">简单分析器</dt>
<dd>
<p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生</p>
<div class="literalblock">
<div class="content">
<pre>set, the, shape, to, semi, transparent, by, calling, set, trans</pre>
</div>
</div>
</dd>
<dt class="hdlist1">空格分析器</dt>
<dd>
<p>空格分析器在空格的地方划分文本。它会产生</p>
<div class="literalblock">
<div class="content">
<pre>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</pre>
</div>
</div>
</dd>
<dt class="hdlist1">语言分析器</dt>
<dd>
<p>特定语言分析器可用于 {ref}/analysis-lang-analyzer.html[很多语言]。它们可以考虑指定语言的特点。例如， <code>英语</code> 分析器附带了一组英语无用词（常用单词，例如 <code>and</code> 或者 <code>the</code> ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 <em>词干</em> 。</p>
<div class="paragraph">
<p><code>英语</code> 分词器会产生下面的词条：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set, shape, semi, transpar, call, set_tran, 5</pre>
</div>
</div>
<div class="paragraph">
<p>注意看 <code>transparent</code>、 <code>calling</code> 和 <code>set_trans</code> 已经变为词根格式。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_什么时候使用分析器">什么时候使用分析器</h4>
<div class="paragraph">
<p>当我们 <em>索引</em> 一个文档，它的全文域被分析成词条以用来创建倒排索引。  但是，当我们在全文域 <em>搜索</em> 的时候，我们需要将查询字符串通过 <em>相同的分析过程</em> ，以保证我们搜索的词条格式与索引中的词条格式一致。</p>
</div>
<div class="paragraph">
<p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当你查询一个 <em>全文</em> 域时， 会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。</p>
</li>
<li>
<p>当你查询一个 <em>精确值</em> 域时，不会分析查询字符串，而是搜索你指定的精确值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在你可以理解在 <a href="#mapping-analysis">开始章节</a> 的查询为什么返回那样的结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>date</code> 域包含一个精确值：单独的词条 <code>2014-09-15</code>。</p>
</li>
<li>
<p><code>_all</code> 域是一个全文域，所以分词进程将日期转化为三个词条： <code>2014</code>， <code>09</code>， 和 <code>15</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当我们在 <code>_all</code> 域查询 <code>2014</code>，它匹配所有的12条推文，因为它们都含有 <code>2014</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /_search?q=2014              # 12 results</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在 <code><em>all</code> 域查询 <code>2014-09-15</code>，它首先分析查询字符串，产生匹配 <code>2014</code>， <code>09</code>， 或 <code>15</code> 中 _任意</em> 词条的查询。这也会匹配所有12条推文，因为它们都含有 <code>2014</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /_search?q=2014-09-15        # 12 results !</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在 <code>date</code> 域查询 <code>2014-09-15</code>，它寻找 <em>精确</em>
日期，只找到一个推文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /_search?q=date:2014-09-15   # 1  result</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在 <code>date</code> 域查询 <code>2014</code>，它找不到任何文档，因为没有文档含有这个精确日志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">GET /_search?q=date:2014         # 0  results !</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="analyze-api">测试分析器</h4>
<div class="paragraph">
<p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 <code>analyze</code> API 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_analyze
{
  "analyzer": "standard",
  "text": "Text to analyze"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果中每个元素代表一个单独的词条：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "tokens": [
      {
         "token":        "text",
         "start_offset": 0,
         "end_offset":   4,
         "type":         "&lt;ALPHANUM&gt;",
         "position":     1
      },
      {
         "token":        "to",
         "start_offset": 5,
         "end_offset":   7,
         "type":         "&lt;ALPHANUM&gt;",
         "position":     2
      },
      {
         "token":        "analyze",
         "start_offset": 8,
         "end_offset":   15,
         "type":         "&lt;ALPHANUM&gt;",
         "position":     3
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>token</code> 是实际存储到索引中的词条。 <code>position</code> 指明词条在原始文本中出现的位置。 <code>start_offset</code> 和 <code>end_offset</code> 指明字符在原始字符串中的位置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
每个分析器的 <code>type</code> 值都不一样，可以忽略它们。它们在Elasticsearch中的唯一作用在于{ref}/analysis-keep-types-tokenfilter.html[<code>keep_types</code> token 过滤器]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>analyze</code> API 是一个有用的工具，它有助于我们理解Elasticsearch索引内部发生了什么，随着深入，我们会进一步讨论它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_指定分析器">指定分析器</h4>
<div class="paragraph">
<p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文 <code>字符串</code> 域，使用 <code>标准</code> 分析器对它进行分析。</p>
</div>
<div class="paragraph">
<p>你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域&#8212;&#8203;不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。</p>
</div>
<div class="paragraph">
<p>要做到这一点，我们必须手动指定这些域的映射。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping-intro">映射</h3>
<div class="paragraph">
<p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。这个信息包含在映射中。</p>
</div>
<div class="paragraph">
<p>如 <a href="#data-in-data-out">数据输入和输出</a> 中解释的，索引中每个文档都有 <em>类型</em> 。每种类型都有它自己的 <em>映射</em> ，或者 <em>模式定义</em> 。映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p>
</div>
<div class="paragraph">
<p>我们会在 <a href="#mapping">类型和映射</a> 详细讨论映射。本节，我们只讨论足够让你入门的内容。</p>
</div>
<div class="sect3">
<h4 id="core-fields">核心简单域类型</h4>
<div class="paragraph">
<p>Elasticsearch 支持如下简单域类型：</p>
</div>
<div class="ulist horizontal">
<ul class="horizontal">
<li>
<p>字符串: <code>string</code></p>
</li>
<li>
<p>整数 : <code>byte</code>, <code>short</code>, <code>integer</code>, <code>long</code></p>
</li>
<li>
<p>浮点数: <code>float</code>, <code>double</code></p>
</li>
<li>
<p>布尔型: <code>boolean</code></p>
</li>
<li>
<p>日期: <code>date</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当你索引一个包含新域的文档&#8212;&#8203;之前未曾出现-- Elasticsearch 会使用 <a href="#dynamic-mapping"><em>动态映射</em></a> ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<strong>JSON type</strong>                       
</td>
<td class="hdlist2">
<p><strong>域 type</strong></p>
</td>
</tr>
<tr>
<td class="hdlist1">
布尔型: <code>true</code> 或者 <code>false</code>         
</td>
<td class="hdlist2">
<p><code>boolean</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
整数: <code>123</code>                
</td>
<td class="hdlist2">
<p><code>long</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
浮点数: <code>123.45</code>           
</td>
<td class="hdlist2">
<p><code>double</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
字符串，有效日期: <code>2014-09-15</code> 
</td>
<td class="hdlist2">
<p><code>date</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
字符串: <code>foo bar</code>                
</td>
<td class="hdlist2">
<p><code>string</code></p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
这意味着如果你通过引号( <code>"123"</code> )索引一个数字，它会被映射为 <code>string</code> 类型，而不是 <code>long</code> 。但是，如果这个域已经映射为 <code>long</code> ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_查看映射">查看映射</h4>
<div class="paragraph">
<p>通过 <code>/_mapping</code> ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射。在 <a href="#mapping-analysis">开始章节</a> ，我们已经取得索引 <code>gb</code> 中类型 <code>tweet</code> 的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /gb/_mapping/tweet</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch 根据我们索引的文档，为域(称为 <em>属性</em> )动态生成的映射。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "gb": {
      "mappings": {
         "tweet": {
            "properties": {
               "date": {
                  "type": "date",
                  "format": "strict_date_optional_time||epoch_millis"
               },
               "name": {
                  "type": "string"
               },
               "tweet": {
                  "type": "string"
               },
               "user_id": {
                  "type": "long"
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>错误的映射，例如 将 <code>age</code> 域映射为 <code>string</code> 类型，而不是 <code>integer</code> ，会导致查询出现令人困惑的结果。</p>
</div>
<div class="paragraph">
<p>检查一下！而不是假设你的映射是正确的。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="custom-field-mappings">自定义域映射</h4>
<div class="paragraph">
<p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全文字符串域和精确值字符串域的区别</p>
</li>
<li>
<p>使用特定语言分析器</p>
</li>
<li>
<p>优化域以适应部分匹配</p>
</li>
<li>
<p>指定自定义数据格式</p>
</li>
<li>
<p>还有更多</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>域最重要的属性是 <code>type</code> 。对于不是 <code>string</code> 的域，你一般只需要设置 <code>type</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "number_of_clicks": {
        "type": "integer"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>string</code> 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p>
</div>
<div class="paragraph">
<p><code>string</code> 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p>
</div>
<div class="sect4">
<h5 id="_index_2">index</h5>
<div class="paragraph">
<p><code>index</code> 属性控制怎样索引字符串。它可以是下面三个值：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>analyzed</code></dt>
<dd>
<p>首先分析字符串，然后索引它。换句话说，以全文索引这个域。</p>
</dd>
<dt class="hdlist1"><code>not_analyzed</code></dt>
<dd>
<p>  索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。</p>
</dd>
<dt class="hdlist1"><code>no</code></dt>
<dd>
<p>不索引这个域。这个域不会被搜索到。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>string</code> 域 <code>index</code> 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 <code>not_analyzed</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "tag": {
        "type":     "string",
        "index":    "not_analyzed"
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>其他简单类型（例如 <code>long</code> ， <code>double</code> ， <code>date</code> 等）也接受 <code>index</code> 参数，但有意义的值只有 <code>no</code> 和 <code>not_analyzed</code> ，
因为它们永远不会被分析。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_analyzer">analyzer</h5>
<div class="paragraph">
<p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如
<code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "tweet": {
        "type":     "string",
        "analyzer": "english"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="#custom-analyzers">自定义分析器</a> ，我们会展示怎样定义和使用自定义分析器。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-a-mapping">更新映射</h4>
<div class="paragraph">
<p>当你首次创建一个索引的时候，可以指定类型的映射。你也可以使用 <code>/_mapping</code> 为新类型（或者为存在的类型更新映射）增加映射。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>尽管你可以 <em>增加</em> 一个存在的映射，你不能 <em>修改</em> 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 <code>analyzed</code> 改为 <code>not_analyzed</code> 。</p>
</div>
<div class="paragraph">
<p>为了描述指定映射的两种方式，我们先删除 <code>gd</code> 索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">DELETE /gb</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建一个新索引，指定 <code>tweet</code> 域使用 <code>english</code> 分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /gb <b class="conum">(1)</b>
{
  "mappings": {
    "tweet" : {
      "properties" : {
        "tweet" : {
          "type" :    "string",
          "analyzer": "english"
        },
        "date" : {
          "type" :   "date"
        },
        "name" : {
          "type" :   "string"
        },
        "user_id" : {
          "type" :   "long"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>通过消息体中指定的 <code>mappings</code> 创建了索引。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>稍后，我们决定在 <code>tweet</code> 映射增加一个新的名为 <code>tag</code> 的 <code>not_analyzed</code> 的文本域，使用 <code>_mapping</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /gb/_mapping/tweet
{
  "properties" : {
    "tag" : {
      "type" :    "string",
      "index":    "not_analyzed"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_测试映射">测试映射</h4>
<div class="paragraph">
<p>你可以使用 <code>analyze</code> API  测试字符串域的映射。比较下面两个请求的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /gb/_analyze
{
  "field": "tweet",
  "text": "Black-cats" <b class="conum">(1)</b>
}

GET /gb/_analyze
{
  "field": "tag",
  "text": "Black-cats" <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>消息体里面传输我们想要分析的文本。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>tweet</code> 域产生两个词条 <code>black</code> 和 <code>cat</code> ， <code>tag</code> 域产生单独的词条 <code>Black-cats</code> 。换句话说，我们的映射正常工作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="complex-core-fields">复杂核心域类型</h3>
<div class="paragraph">
<p>除了我们提到的简单标量数据类型， JSON 还有 <code>null</code> 值，数组，和对象，这些 Elasticsearch 都是支持的。</p>
</div>
<div class="sect3">
<h4 id="_多值域">多值域</h4>
<div class="paragraph">
<p>很有可能，我们希望 <code>tag</code> 域包含多个标签。我们可以以数组的形式索引标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "tag": [ "search", "nosql" ]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于数组，没有特殊的映射需求。任何域都可以包含0、1或者多个值，就像全文域分析得到多个词条。</p>
</div>
<div class="paragraph">
<p>这暗示 <em>数组中所有的值必须是相同数据类型的</em> 。你不能将日期和字符串混在一起。如果你通过索引数组来创建新的域，Elasticsearch 会用数组中第一个值的数据类型作为这个域的 <code>类型</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>当你从 Elasticsearch 得到一个文档，每个数组的顺序和你当初索引文档时一样。你得到的 <code>_source</code> 域，包含与你索引的一模一样的 JSON 文档。</p>
</div>
<div class="paragraph">
<p>但是，数组是以多值域 <em>索引的</em>&#x2014;可以搜索，但是无序的。  在搜索的时候，你不能指定 “第一个” 或者 “最后一个”。 更确切的说，把数组想象成 <em>装在袋子里的值</em> 。
</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_空域">空域</h4>
<div class="paragraph">
<p>当然，数组可以为空。这相当于存在零值。
事实上，在 Lucene 中是不能存储 <code>null</code> 值的，所以我们认为存在 <code>null</code> 值的域为空域。</p>
</div>
<div class="paragraph">
<p>下面三种域被认为是空的，它们将不会被索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"null_value":               null,
"empty_array":              [],
"array_with_null_value":    [ null ]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="inner-objects">多层级对象</h4>
<div class="paragraph">
<p>我们讨论的最后一个 JSON 原生数据类是 <em>对象</em> -- 在其他语言中称为哈希，哈希 map，字典或者关联数组。</p>
</div>
<div class="paragraph">
<p><em>内部对象</em> 经常用于嵌入一个实体或对象到其它对象中。例如，与其在 <code>tweet</code> 文档中包含 <code>user_name</code> 和 <code>user_id</code> 域，我们也可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "tweet":            "Elasticsearch is very flexible",
    "user": {
        "id":           "@johnsmith",
        "gender":       "male",
        "age":          26,
        "name": {
            "full":     "John Smith",
            "first":    "John",
            "last":     "Smith"
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_内部对象的映射">内部对象的映射</h4>
<div class="paragraph">
<p>Elasticsearch 会动态监测新的对象域并映射它们为 <code>对象</code> ，在  <code>properties</code> 属性下列出内部域：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "gb": {
    "tweet": { <b class="conum">(1)</b>
      "properties": {
        "tweet":            { "type": "string" },
        "user": { <b class="conum">(2)</b>
          "type":             "object",
          "properties": {
            "id":           { "type": "string" },
            "gender":       { "type": "string" },
            "age":          { "type": "long"   },
            "name":   { <b class="conum">(2)</b>
              "type":         "object",
              "properties": {
                "full":     { "type": "string" },
                "first":    { "type": "string" },
                "last":     { "type": "string" }
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>根对象</p>
</li>
<li>
<p>内部对象</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>user</code> 和 <code>name</code> 域的映射结构与 <code>tweet</code> 类型的相同。事实上， <code>type</code> 映射只是一种特殊的 <code>对象</code> 映射，我们称之为 <em>根对象</em> 。除了它有一些文档元数据的特殊顶级域，例如 <code>_source</code> 和 <code>_all</code> 域，它和其他对象一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_内部对象是如何索引的">内部对象是如何索引的</h4>
<div class="paragraph">
<p>Lucene 不理解内部对象。 Lucene 文档是由一组键值对列表组成的。为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "tweet":            [elasticsearch, flexible, very],
    "user.id":          [@johnsmith],
    "user.gender":      [male],
    "user.age":         [26],
    "user.name.full":   [john, smith],
    "user.name.first":  [john],
    "user.name.last":   [smith]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>内部域</em> 可以通过名称引用（例如， <code>first</code> ）。为了区分同名的两个域，我们可以使用全 <em>路径</em> （例如， <code>user.name.first</code> ） 或 <code>type</code> 名加路径（ <code>tweet.user.name.first</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
在前面简单扁平的文档中，没有 <code>user</code>
和 <code>user.name</code> 域。Lucene 索引只有标量和简单值，没有复杂数据结构。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="object-arrays">内部对象数组</h4>
<div class="paragraph">
<p>最后，考虑包含内部对象的数组是如何被索引的。
假设我们有个 <code>followers</code> 数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "followers": [
        { "age": 35, "name": "Mary White"},
        { "age": 26, "name": "Alex Jones"},
        { "age": 19, "name": "Lisa Smith"}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个文档会像我们之前描述的那样被扁平化处理，结果如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "followers.age":    [19, 26, 35],
    "followers.name":   [alex, jones, lisa, smith, mary, white]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{age: 35}</code> 和 <code>{name: Mary White}</code> 之间的相关性已经丢失了，因为每个多值域只是一包无序的值，而不是有序数组。这足以让我们问，“有一个26岁的追随者？”</p>
</div>
<div class="paragraph">
<p>但是我们不能得到一个准确的答案：“是否有一个26岁 <em>名字叫 Alex Jones</em> 的追随者？”</p>
</div>
<div class="paragraph">
<p>相关内部对象被称为 <em>nested</em> 对象，可以回答上面的查询，我们稍后会在<a href="#nested-objects">[nested-objects]</a>中介绍它。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="full-body-search">请求体查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>简易</em>  查询 &#x2014;<a href="#search-lite">query-string search</a>&#x2014; 对于用命令行进行即席查询（ad-hoc）是非常有用的。然而，为了充分利用查询的强大功能，你应该使用 <em>请求体</em> <code>search</code> API， 之所以称之为请求体查询(Full-Body Search)，因为大部分参数是通过 Http 请求体而非查询字符串来传递的。</p>
</div>
<div class="paragraph">
<p>请求体查询 &#x2014;下文简称 <em>查询</em>&#x2014;不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 <em>你是不是想找</em> 的建议，这些建议可以引导使用者快速找到他想要的结果。</p>
</div>
<div class="sect2">
<h3 id="_empty_search">空查询</h3>
<div class="paragraph">
<p>让我们以最简单的 <code>search</code> API 的形式开启我们的旅程，空查询将返回所有索引库（indices)中的所有文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{} <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这是一个空的请求体。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>只用一个查询字符串，你就可以在一个、多个或者 <code>_all</code> 索引库（indices）和一个、多个或者所有types中查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /index_2014*/type1,type2/_search
{}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同时你可以使用 <code>from</code> 和 <code>size</code> 参数来分页：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
  "from": 30,
  "size": 10
}</code></pre>
</div>
</div>
<div id="get_vs_post" class="sidebarblock">
<div class="content">
<div class="title">一个带请求体的 GET 请求？</div>
<div class="paragraph">
<p>某些特定语言（特别是 JavaScript）的 HTTP 库是不允许 <code>GET</code> 请求带有请求体的。事实上，一些使用者对于 <code>GET</code> 请求可以带请求体感到非常的吃惊。</p>
</div>
<div class="paragraph">
<p>而事实是这个RFC文档 <a href="http://tools.ietf.org/html/rfc7231#page-24">RFC 7231</a>&#x2014; 一个专门负责处理 HTTP 语义和内容的文档&#8201;&#8212;&#8201;并没有规定一个带有请求体的 <code>GET</code> 请求应该如何处理！结果是，一些 HTTP 服务器允许这样子，而有一些&#8201;&#8212;&#8201;特别是一些用于缓存和代理的服务器&#8201;&#8212;&#8201;则不允许。</p>
</div>
<div class="paragraph">
<p>对于一个查询请求，Elasticsearch 的工程师偏向于使用 <code>GET</code> 方式，因为他们觉得它比 <code>POST</code> 能更好的描述信息检索（retrieving information）的行为。然而，因为带请求体的 <code>GET</code> 请求并不被广泛支持，所以 <code>search</code> API同时支持 <code>POST</code> 请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_search
{
  "from": 30,
  "size": 10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似的规则可以应用于任何需要带请求体的 <code>GET</code> API。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>我们将在聚合 <a href="#aggregations">[aggregations]</a> 章节深入介绍聚合（aggregations），而现在，我们将聚焦在查询。</p>
</div>
<div class="paragraph">
<p>相对于使用晦涩难懂的查询字符串的方式，一个带请求体的查询允许我们使用 <em>查询领域特定语言（query domain-specific language）</em> 或者 Query DSL 来写查询语句。</p>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-intro">查询表达式</h3>
<div class="paragraph">
<p>查询表达式(Query DSL)是一种非常灵活又富有表现力的  查询语言。 Elasticsearch 使用它可以以简单的 JSON 接口来展现 Lucene 功能的绝大部分。在你的应用中，你应该用它来编写你的查询语句。它可以使你的查询语句更灵活、更精确、易读和易调试。</p>
</div>
<div class="paragraph">
<p>要使用这种查询表达式，只需将查询语句传递给 <code>query</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query": YOUR_QUERY_HERE
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>空查询（empty search）</em> &#x2014;`{}`&#x2014; 在功能上等价于使用 <code>match_all</code> 查询， 正如其名字一样，匹配所有文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query": {
        "match_all": {}
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_查询语句的结构">查询语句的结构</h4>
<div class="paragraph">
<p>一个查询语句的典型结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    QUERY_NAME: {
        ARGUMENT: VALUE,
        ARGUMENT: VALUE,...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果是针对某个字段，那么它的结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    QUERY_NAME: {
        FIELD_NAME: {
            ARGUMENT: VALUE,
            ARGUMENT: VALUE,...
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>举个例子，你可以使用 <code>match</code> 查询语句 来查询 <code>tweet</code> 字段中包含 <code>elasticsearch</code> 的 tweet：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "match": {
        "tweet": "elasticsearch"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的查询请求如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query": {
        "match": {
            "tweet": "elasticsearch"
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_合并查询语句">合并查询语句</h4>
<div class="paragraph">
<p><em>查询语句(Query clauses)</em> 就像一些简单的组合块，这些组合块可以彼此之间合并组成更复杂的查询。这些语句可以是如下形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>叶子语句（Leaf clauses）</em> (就像 <code>match</code> 语句)  被用于将查询字符串和一个字段（或者多个字段）对比。</p>
</li>
<li>
<p><em>复合(Compound)</em> 语句 主要用于  合并其它查询语句。
比如，一个 <code>bool</code> 语句 允许在你需要的时候组合其它语句，无论是  <code>must</code> 匹配、 <code>must_not</code> 匹配还是 <code>should</code> 匹配，同时它可以包含不评分的过滤器（filters）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "bool": {
        "must":     { "match": { "tweet": "elasticsearch" }},
        "must_not": { "match": { "name":  "mary" }},
        "should":   { "match": { "tweet": "full text" }},
        "filter":   { "range": { "age" : { "gt" : 30 }} }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一条复合语句可以合并 <em>任何</em> 其它查询语句，包括复合语句，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p>
</div>
<div class="paragraph">
<p>例如，以下查询是为了找出信件正文包含 <code>business opportunity</code> 的星标邮件，或者在收件箱正文包含  <code>business opportunity</code> 的非垃圾邮件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "bool": {
        "must": { "match":   { "email": "business opportunity" }},
        "should": [
            { "match":       { "starred": true }},
            { "bool": {
                "must":      { "match": { "folder": "inbox" }},
                "must_not":  { "match": { "spam": true }}
            }}
        ],
        "minimum_should_match": 1
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，你不必太在意这个例子的细节，我们会在后面详细解释。最重要的是你要理解到，一条复合语句可以将多条语句&#8201;&#8212;&#8201;叶子语句和其它复合语句&#8201;&#8212;&#8201;合并成一个单一的查询语句。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_queries_and_filters">查询与过滤</h3>
<div class="paragraph">
<p>Elasticsearch 使用的查询语言（DSL）拥有一套查询组件，这些组件可以以无限组合的方式进行搭配。这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。</p>
</div>
<div class="paragraph">
<p>当使用于 <em>过滤情况</em> 时，查询被设置成一个“不评分”或者“过滤”查询。即，这个查询只是简单的问一个问题：“这篇文档是否匹配？”。回答也是非常的简单，yes 或者 no ，二者必居其一。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>created</code> 时间是否在 <code>2013</code> 与 <code>2014</code> 这个区间？</p>
</li>
<li>
<p><code>status</code> 字段是否包含 <code>published</code> 这个单词？</p>
</li>
<li>
<p><code>lat_lon</code> 字段表示的位置是否在指定点的 <code>10km</code> 范围内？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当使用于 <em>查询情况</em> 时，查询就变成了一个“评分”的查询。和不评分的查询类似，也要去判断这个文档是否匹配，同时它还需要判断这个文档匹配的有 <em>多好</em>（匹配程度如何）。
此查询的典型用法是用于查找以下文档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>查找与 <code>full text search</code> 这个词语最佳匹配的文档</p>
</li>
<li>
<p>包含 <code>run</code> 这个词，也能匹配 <code>runs</code> 、 <code>running</code> 、 <code>jog</code> 或者 <code>sprint</code></p>
</li>
<li>
<p>包含  <code>quick</code> 、 <code>brown</code> 和 <code>fox</code> 这几个词 &#x2014; 词之间离的越近，文档相关性越高</p>
</li>
<li>
<p>标有 <code>lucene</code> 、 <code>search</code> 或者 <code>java</code> 标签 &#x2014; 标签越多，相关性越高</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个评分查询计算每一个文档与此查询的 <em>相关程度</em>，同时将这个相关程度分配给表示相关性的字段 <code>_score</code>，并且按照相关性对匹配到的文档进行排序。这种相关性的概念是非常适合全文搜索的情况，因为全文搜索几乎没有完全 ``正确'' 的答案。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>自 Elasticsearch 问世以来，查询与过滤（queries and filters）就独自成为 Elasticsearch 的组件。但从 Elasticsearch 2.0 开始，过滤（filters）已经从技术上被排除了，同时所有的查询（queries）拥有变成不评分查询的能力。</p>
</div>
<div class="paragraph">
<p>然而，为了明确和简单，我们用 "filter" 这个词表示不评分、只过滤情况下的查询。你可以把 "filter" 、 "filtering query" 和 "non-scoring query" 这几个词视为相同的。</p>
</div>
<div class="paragraph">
<p>相似的，如果单独地不加任何修饰词地使用 "query" 这个词，我们指的是 "scoring query" 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_性能差异">性能差异</h4>
<div class="paragraph">
<p>过滤查询（Filtering queries）只是简单的检查包含或者排除，这就使得计算起来非常快。考虑到至少有一个过滤查询（filtering query）的结果是 “稀少的”（很少匹配的文档），并且经常使用不评分查询（non-scoring queries），结果会被缓存到内存中以便快速读取，所以有各种各样的手段来优化查询结果。</p>
</div>
<div class="paragraph">
<p>相反，评分查询（scoring queries）不仅仅要找出匹配的文档，还要计算每个匹配文档的相关性，计算相关性使得它们比不评分查询费力的多。同时，查询结果并不缓存。</p>
</div>
<div class="paragraph">
<p>多亏倒排索引（inverted index），一个简单的评分查询在匹配少量文档时可能与一个涵盖百万文档的filter表现的一样好，甚至会更好。但是在一般情况下，一个filter 会比一个评分的query性能更优异，并且每次都表现的很稳定。</p>
</div>
<div class="paragraph">
<p>过滤（filtering）的目标是减少那些需要通过评分查询（scoring queries）进行检查的文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何选择查询与过滤">如何选择查询与过滤</h4>
<div class="paragraph">
<p>通常的规则是，使用查询（query）语句来进行 <em>全文</em> 搜索或者其它任何需要影响 <em>相关性得分</em> 的搜索。除此以外的情况都使用过滤（filters)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_most_important_queries">最重要的查询</h3>
<div class="paragraph">
<p>虽然 Elasticsearch 自带了很多的查询，但经常用到的也就那么几个。我们将在 <a href="#search-in-depth">[search-in-depth]</a> 章节详细讨论那些查询的细节，接下来我们对最重要的几个查询进行简单介绍。</p>
</div>
<div class="sect3">
<h4 id="_match_all_查询">match_all 查询</h4>
<div class="paragraph">
<p><code>match_all</code> 查询简单的匹配所有文档。在没有指定查询方式时，它是默认的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "match_all": {}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它经常与 filter 结合使用&#8212;&#8203;例如，检索收件箱里的所有邮件。所有邮件被认为具有相同的相关性，所以都将获得分值为 <code>1</code> 的中性 <code>_score</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_match_查询">match 查询</h4>
<div class="paragraph">
<p>无论你在任何字段上进行的是全文搜索还是精确查询，<code>match</code> 查询是你可用的标准查询。</p>
</div>
<div class="paragraph">
<p>如果你在一个全文字段上使用 <code>match</code> 查询，在执行查询前，它将用正确的分析器去分析查询字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "match": { "tweet": "About Search" }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在一个精确值的字段上使用它，例如数字、日期、布尔或者一个 <code>not_analyzed</code> 字符串字段，那么它将会精确匹配给定的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "match": { "age":    26           }}
{ "match": { "date":   "2014-09-01" }}
{ "match": { "public": true         }}
{ "match": { "tag":    "full_text"  }}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
对于精确值的查询，你可能需要使用 filter 语句来取代 query，因为 filter 将会被缓存。接下来，我们将看到一些关于 filter 的例子。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>不像我们在 <a href="#search-lite"><em>轻量</em> 搜索</a> 章节介绍的字符串查询（query-string search）， <code>match</code> 查询不使用类似 <code>+user_id:2 +tweet:search</code> 的查询语法。它只是去查找给定的单词。这就意味着将查询字段暴露给你的用户是安全的；你需要控制那些允许被查询字段，不易于抛出语法异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="_multi_match_查询">multi_match 查询</h4>
<div class="paragraph">
<p><code>multi_match</code> 查询可以在多个字段上执行相同的 <code>match</code> 查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "multi_match": {
        "query":    "full text search",
        "fields":   [ "title", "body" ]
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_range_查询">range 查询</h4>
<div class="paragraph">
<p><code>range</code> 查询找出那些落在指定区间内的数字或者时间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "range": {
        "age": {
            "gte":  20,
            "lt":   30
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>被允许的操作符如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>gt</code></dt>
<dd>
<p>大于</p>
</dd>
<dt class="hdlist1"><code>gte</code></dt>
<dd>
<p>大于等于</p>
</dd>
<dt class="hdlist1"><code>lt</code></dt>
<dd>
<p>小于</p>
</dd>
<dt class="hdlist1"><code>lte</code></dt>
<dd>
<p>小于等于</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_term_查询">term 查询</h4>
<div class="paragraph">
<p><code>term</code> 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 <code>not_analyzed</code> 的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "term": { "age":    26           }}
{ "term": { "date":   "2014-09-01" }}
{ "term": { "public": true         }}
{ "term": { "tag":    "full_text"  }}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>term</code> 查询对于输入的文本不 <em>分析</em> ，所以它将给定的值进行精确查询。</p>
</div>
</div>
<div class="sect3">
<h4 id="_terms_查询">terms 查询</h4>
<div class="paragraph">
<p><code>terms</code> 查询和 <code>term</code> 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "terms": { "tag": [ "search", "full_text", "nosql" ] }}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和 <code>term</code> 查询一样，<code>terms</code> 查询对于输入的文本不分析。它查询那些精确匹配的值（包括在大小写、重音、空格等方面的差异）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_exists_查询和_missing_查询">exists 查询和 missing 查询</h4>
<div class="paragraph">
<p><code>exists</code> 查询和 <code>missing</code> 查询被用于查找那些指定字段中有值 (<code>exists</code>) 或无值 (<code>missing</code>) 的文档。这与SQL中的 <code>IS_NULL</code> (<code>missing</code>) 和 <code>NOT IS_NULL</code> (<code>exists</code>) 在本质上具有共性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "exists":   {
        "field":    "title"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些查询经常用于某个字段有值的情况和某个字段缺值的情况。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="combining-queries-together">组合多查询</h3>
<div class="paragraph">
<p>现实的查询需求从来都没有那么简单；它们需要在多个字段上查询多种多样的文本，并且根据一系列的标准来过滤。为了构建类似的高级查询，你需要一种能够将多查询组合成单一查询的查询方法。</p>
</div>
<div class="paragraph">
<p>你可以用 <code>bool</code> 查询来实现你的需求。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>must</code></dt>
<dd>
<p>文档 <em>必须</em> 匹配这些条件才能被包含进来。</p>
</dd>
<dt class="hdlist1"><code>must_not</code></dt>
<dd>
<p>文档 <em>必须不</em> 匹配这些条件才能被包含进来。</p>
</dd>
<dt class="hdlist1"><code>should</code></dt>
<dd>
<p>如果满足这些语句中的任意语句，将增加 <code>_score</code> ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。</p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p><em>必须</em> 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>由于这是我们看到的第一个包含多个查询的查询，所以有必要讨论一下相关性得分是如何组合的。每一个子查询都独自地计算文档的相关性得分。一旦他们的得分被计算出来， <code>bool</code> 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。</p>
</div>
<div class="paragraph">
<p>下面的查询用于查找 <code>title</code> 字段匹配 <code>how to make millions</code> 并且不被标识为 <code>spam</code> 的文档。那些被标识为 <code>starred</code> 或在2014之后的文档，将比另外那些文档拥有更高的排名。如果 <em>两者</em> 都满足，那么它排名将更高：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "bool": {
        "must":     { "match": { "title": "how to make millions" }},
        "must_not": { "match": { "tag":   "spam" }},
        "should": [
            { "match": { "tag": "starred" }},
            { "range": { "date": { "gte": "2014-01-01" }}}
        ]
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
如果没有 <code>must</code> 语句，那么至少需要能够匹配其中的一条 <code>should</code> 语句。但，如果存在至少一条 <code>must</code> 语句，则对 <code>should</code> 语句的匹配没有要求。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="adding-a-filtering-query">增加带过滤器（filtering）的查询</h4>
<div class="paragraph">
<p>如果我们不想因为文档的时间而影响得分，可以用 <code>filter</code> 语句来重写前面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "bool": {
        "must":     { "match": { "title": "how to make millions" }},
        "must_not": { "match": { "tag":   "spam" }},
        "should": [
            { "match": { "tag": "starred" }}
        ],
        "filter": {
          "range": { "date": { "gte": "2014-01-01" }} <b class="conum">(1)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>range 查询已经从 <code>should</code> 语句中移到 <code>filter</code> 语句</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过将 range 查询移到 <code>filter</code> 语句中，我们将它转成不评分的查询，将不再影响文档的相关性排名。由于它现在是一个不评分的查询，可以使用各种对 filter 查询有效的优化手段来提升性能。</p>
</div>
<div class="paragraph">
<p>所有查询都可以借鉴这种方式。将查询移到 <code>bool</code> 查询的 <code>filter</code> 语句中，这样它就自动的转成一个不评分的 filter 了。</p>
</div>
<div class="paragraph">
<p>如果你需要通过多个不同的标准来过滤你的文档，<code>bool</code> 查询本身也可以被用做不评分的查询。简单地将它放置到  <code>filter</code> 语句中并在内部构建布尔逻辑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "bool": {
        "must":     { "match": { "title": "how to make millions" }},
        "must_not": { "match": { "tag":   "spam" }},
        "should": [
            { "match": { "tag": "starred" }}
        ],
        "filter": {
          "bool": { <b class="conum">(1)</b>
              "must": [
                  { "range": { "date": { "gte": "2014-01-01" }}},
                  { "range": { "price": { "lte": 29.99 }}}
              ],
              "must_not": [
                  { "term": { "category": "ebooks" }}
              ]
          }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>将 <code>bool</code> 查询包裹在 <code>filter</code> 语句中，我们可以在过滤标准中增加布尔逻辑</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过混合布尔查询，我们可以在我们的查询请求中灵活地编写 scoring 和 filtering 查询逻辑。</p>
</div>
</div>
<div class="sect3">
<h4 id="constant_score-query">constant_score 查询</h4>
<div class="paragraph">
<p>尽管没有 <code>bool</code> 查询使用这么频繁，<code>constant_score</code> 查询也是你工具箱里有用的查询工具。它将一个不变的常量评分应用于所有匹配的文档。它被经常用于你只需要执行一个 filter 而没有其它查询（例如，评分查询）的情况下。</p>
</div>
<div class="paragraph">
<p>可以使用它来取代只有 filter 语句的 <code>bool</code> 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "constant_score":   {
        "filter": {
            "term": { "category": "ebooks" } <b class="conum">(1)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>term</code> 查询被放置在 <code>constant_score</code> 中，转成不评分的 filter。这种方式可以用来取代只有 filter 语句的 <code>bool</code> 查询。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validating-queries">验证查询</h3>
<div class="paragraph">
<p>查询可以变得非常的复杂，尤其和不同的分析器与不同的字段映射结合时，理解起来就有点困难了。不过 <code>validate-query</code> API 可以用来验证查询是否合法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /gb/tweet/_validate/query
{
   "query": {
      "tweet" : {
         "match" : "really powerful"
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上 <code>validate</code> 请求的应答告诉我们这个查询是不合法的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "valid" :         false,
  "_shards" : {
    "total" :       1,
    "successful" :  1,
    "failed" :      0
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="understanding-errors">理解错误信息</h4>
<div class="paragraph">
<p>为了找出  查询不合法的原因，可以将 <code>explain</code> 参数 加到查询字符串中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /gb/tweet/_validate/query?explain <b class="conum">(1)</b>
{
   "query": {
      "tweet" : {
         "match" : "really powerful"
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>explain</code> 参数可以提供更多关于查询不合法的信息。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>很明显，我们将查询类型(<code>match</code>)与字段名称 (<code>tweet</code>)搞混了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "valid" :     false,
  "_shards" :   { ... },
  "explanations" : [ {
    "index" :   "gb",
    "valid" :   false,
    "error" :   "org.elasticsearch.index.query.QueryParsingException:
                 [gb] No query registered for [tweet]"
  } ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="understanding-queries">理解查询语句</h4>
<div class="paragraph">
<p>对于合法查询，使用 <code>explain</code> 参数将返回可读的描述，这对准确理解 Elasticsearch 是如何解析你的 query 是非常有用的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_validate/query?explain
{
   "query": {
      "match" : {
         "tweet" : "really powerful"
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们查询的每一个 index 都会返回对应的 <code>explanation</code> ，因为每一个 index 都有自己的映射和分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "valid" :         true,
  "_shards" :       { ... },
  "explanations" : [ {
    "index" :       "us",
    "valid" :       true,
    "explanation" : "tweet:really tweet:powerful"
  }, {
    "index" :       "gb",
    "valid" :       true,
    "explanation" : "tweet:realli tweet:power"
  } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 <code>explanation</code> 中可以看出，匹配 <code>really powerful</code> 的 <code>match</code> 查询被重写为两个针对 <code>tweet</code> 字段的 single-term 查询，一个single-term查询对应查询字符串分出来的一个term。</p>
</div>
<div class="paragraph">
<p>当然，对于索引 <code>us</code> ，这两个 term 分别是 <code>really</code> 和 <code>powerful</code> ，而对于索引 <code>gb</code> ，term 则分别是 <code>realli</code> 和 <code>power</code> 。之所以出现这个情况，是由于我们将索引 <code>gb</code> 中 <code>tweet</code> 字段的分析器修改为 <code>english</code> 分析器。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sorting">排序与相关性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下，返回的结果是按照 <em>相关性</em> 进行排序的&#x2014;&#x2014;最相关的文档排在最前。
在本章的后面部分，我们会解释 <em>相关性</em> 意味着什么以及它是如何计算的，
不过让我们首先看看 <code>sort</code> 参数以及如何使用它。</p>
</div>
<div class="sect2">
<h3 id="_Sorting">排序</h3>
<div class="paragraph">
<p>为了按照相关性来排序，需要将相关性表示为一个数值。在 Elasticsearch 中， <em>相关性得分</em> 由一个浮点数进行表示，并在搜索结果中通过  <code>_score</code> 参数返回，

默认排序是 <code>_score</code> 降序。</p>
</div>
<div class="paragraph">
<p>有时，相关性评分对你来说并没有意义。例如，下面的查询返回所有 <code>user_id</code> 字段包含 <code>1</code> 的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query" : {
        "bool" : {
            "filter" : {
                "term" : {
                    "user_id" : 1
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里没有一个有意义的分数：因为我们使用的是 filter （过滤），这表明我们只希望获取匹配 <code>user_id: 1</code> 的文档，并没有试图确定这些文档的相关性。
实际上文档将按照随机顺序返回，并且每个文档都会评为零分。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>如果评分为零对你造成了困扰，你可以使用 <code>constant_score</code> 查询进行替代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query" : {
        "constant_score" : {
            "filter" : {
                "term" : {
                    "user_id" : 1
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将让所有文档应用一个恒定分数（默认为 <code>1</code> ）。它将执行与前述查询相同的查询，并且所有的文档将像之前一样随机返回，这些文档只是有了一个分数而不是零分。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_Sorting_by_Field_Values">按照字段的值排序</h4>
<div class="paragraph">
<p>在这个案例中，通过时间来对 tweets 进行排序是有意义的，最新的 tweets 排在最前。

我们可以使用 <code>sort</code> 参数进行实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query" : {
        "bool" : {
            "filter" : { "term" : { "user_id" : 1 }}
        }
    },
    "sort": { "date": { "order": "desc" }}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会注意到结果中的两个不同点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"hits" : {
    "total" :           6,
    "max_score" :       null, <b class="conum">(1)</b>
    "hits" : [ {
        "_index" :      "us",
        "_type" :       "tweet",
        "_id" :         "14",
        "_score" :      null, <b class="conum">(1)</b>
        "_source" :     {
             "date":    "2014-09-24",
             ...
        },
        "sort" :        [ 1411516800000 ] <b class="conum">(2)</b>
    },
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>_score</code> 不被计算, 因为它并没有用于排序。</p>
</li>
<li>
<p><code>date</code> 字段的值表示为自 epoch (January 1, 1970 00:00:00 UTC)以来的毫秒数，通过 <code>sort</code> 字段的值进行返回。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>首先我们在每个结果中有一个新的名为 <code>sort</code> 的元素，它包含了我们用于排序的值。
在这个案例中，我们按照 <code>date</code> 进行排序，在内部被索引为 <em>自 epoch 以来的毫秒数</em> 。
long 类型数 <code>1411516800000</code> 等价于日期字符串 <code>2014-09-24 00:00:00 UTC</code> 。</p>
</div>
<div class="paragraph">
<p>其次 <code>_score</code> 和 <code>max_score</code> 字段都是 <code>null</code> 。计算 <code>_score</code> 的花销巨大，通常仅用于排序；
我们并不根据相关性排序，所以记录 <code>_score</code> 是没有意义的。如果无论如何你都要计算 <code>_score</code> ，
你可以将 <code>track_scores</code> 参数设置为 <code>true</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>一个简便方法是, 你可以指定一个字段用来排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">    "sort": "number_of_children"</code></pre>
</div>
</div>
<div class="paragraph">
<p>字段将会默认升序排序，而按照 <code>_score</code> 的值进行降序排序。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_Multilevel_Sorting">多级排序</h4>
<div class="paragraph">
<p>假定我们想要结合使用 <code>date</code> 和 <code>_score</code> 进行查询，并且匹配的结果首先按照日期排序，然后按照相关性排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query" : {
        "bool" : {
            "must":   { "match": { "tweet": "manage text search" }},
            "filter" : { "term" : { "user_id" : 2 }}
        }
    },
    "sort": [
        { "date":   { "order": "desc" }},
        { "_score": { "order": "desc" }}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 <code>sort</code> 值完全相同时才会按照第二个条件进行排序，以此类推。</p>
</div>
<div class="paragraph">
<p>多级排序并不一定包含 <code>_score</code> 。你可以根据一些不同的字段进行排序，如地理距离或是脚本计算的特定值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Query-string 搜索
也支持自定义排序，可以在查询字符串中使用 <code>sort</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_Sorting_on_Multivalue_Fields">多值字段的排序</h4>
<div class="paragraph">
<p>一种情形是字段有多个值的排序，
需要记住这些值并没有固有的顺序；一个多值的字段仅仅是多个值的包装，这时应该选择哪个进行排序呢？</p>
</div>
<div class="paragraph">
<p>对于数字或日期，你可以将多值字段减为单值，这可以通过使用 <code>min</code> 、 <code>max</code> 、 <code>avg</code> 或是 <code>sum</code> <em>排序模式</em> 。

例如你可以按照每个 <code>date</code> 字段中的最早日期进行排序，通过以下方法：</p>
</div>
<div class="listingblock pagebreak-before">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"sort": {
    "dates": {
        "order": "asc",
        "mode":  "min"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multi-fields">字符串排序与多字段</h3>
<div class="paragraph">
<p>被解析的字符串字段也是多值字段， 但是很少会按照你想要的方式进行排序。如果你想分析一个字符串，如 <code>fine old art</code> ，
这包含 3 项。我们很可能想要按第一项的字母排序，然后按第二项的字母排序，诸如此类，但是 Elasticsearch 在排序过程中没有这样的信息。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>min</code> 和 <code>max</code>  排序模式（默认是 <code>min</code> ），但是这会导致排序以 <code>art</code> 或是 <code>old</code> ，任何一个都不是所希望的。</p>
</div>
<div class="paragraph">
<p>为了以字符串字段进行排序，这个字段应仅包含一项：
整个 <code>not_analyzed</code> 字符串。  但是我们仍需要 <code>analyzed</code> 字段，这样才能以全文进行查询</p>
</div>
<div class="paragraph">
<p>一个简单的方法是用两种方式对同一个字符串进行索引，这将在文档中包括两个字段： <code>analyzed</code> 用于搜索， <code>not_analyzed</code> 用于排序</p>
</div>
<div class="paragraph">
<p>但是保存相同的字符串两次在 <code><em>source</code> 字段是浪费空间的。
我们真正想要做的是传递一个 _单字段</em> 但是却用两种方式索引它。所有的 _core_field 类型 (strings, numbers, Booleans, dates) 接收一个 <code>fields</code> 参数</p>
</div>
<div class="paragraph">
<p>该参数允许你转化一个简单的映射如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"tweet": {
    "type":     "string",
    "analyzer": "english"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为一个多字段映射如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"tweet": { <b class="conum">(1)</b>
    "type":     "string",
    "analyzer": "english",
    "fields": {
        "raw": { <b class="conum">(2)</b>
            "type":  "string",
            "index": "not_analyzed"
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>tweet</code> 主字段与之前的一样: 是一个 <code>analyzed</code> 全文字段。</p>
</li>
<li>
<p>新的 <code>tweet.raw</code> 子字段是 <code>not_analyzed</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在，至少只要我们重新索引了我们的数据，使用 <code>tweet</code> 字段用于搜索，<code>tweet.raw</code> 字段用于排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query": {
        "match": {
            "tweet": "elasticsearch"
        }
    },
    "sort": "tweet.raw"
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
以全文 <code>analyzed</code> 字段排序会消耗大量的内存。获取更多信息请看 <a href="#aggregations-and-analysis">[aggregations-and-analysis]</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="relevance-intro">什么是相关性?</h3>
<div class="paragraph">
<p>我们曾经讲过，默认情况下，返回结果是按相关性倒序排列的。
但是什么是相关性？ 相关性如何计算？</p>
</div>
<div class="paragraph">
<p>每个文档都有相关性评分，用一个正浮点数字段 <code>_score</code> 来表示 。 <code>_score</code> 的评分越高，相关性越高。</p>
</div>
<div class="paragraph">
<p>查询语句会为每个文档生成一个 <code><em>score</code> 字段。评分的计算方式取决于查询类型 
不同的查询语句用于不同的目的： <code>fuzzy</code> 查询会计算与关键词的拼写相似程度，<code>terms</code> 查询会计算
找到的内容与关键词组成部分匹配的百分比，但是通常我们说的 _relevance</em> 是我们用来计算全文本字段的值相对于全文本检索词相似程度的算法。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 的相似度算法被定义为检索词频率/反向文档频率， <em>TF/IDF</em> ，包括以下内容：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">检索词频率</dt>
<dd>
<p>检索词在该字段出现的频率？出现频率越高，相关性也越高。 字段中出现过 5 次要比只出现过 1 次的相关性高。</p>
</dd>
<dt class="hdlist1">反向文档频率</dt>
<dd>
<p>每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。</p>
</dd>
<dt class="hdlist1">字段长度准则</dt>
<dd>
<p>字段的长度是多少？长度越长，相关性越低。 检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>单个查询可以联合使用 TF/IDF 和其他方式，比如短语查询中检索词的距离或模糊查询里的检索词相似度。</p>
</div>
<div class="paragraph">
<p>相关性并不只是全文本检索的专利。也适用于 yes|no 的子句，匹配的子句越多，相关性评分越高。</p>
</div>
<div class="paragraph">
<p>如果多条查询子句被合并为一条复合查询语句，比如 bool 查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
我们有一️整章着眼于相关性计算和如何让其配合你的需求 <a href="#controlling-relevance">[controlling-relevance]</a>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="explain">理解评分标准</h4>
<div class="paragraph">
<p>当调试一条复杂的查询语句时，想要理解  <code>_score</code> 究竟是如何计算是比较困难的。Elasticsearch 在
每个查询语句中都有一个 explain 参数，将 <code>explain</code> 设为 <code>true</code>  就可以得到更详细的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?explain <b class="conum">(1)</b>
{
   "query"   : { "match" : { "tweet" : "honeymoon" }}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>explain</code> 参数可以让返回结果添加一个 <code>_score</code> 评分的得来依据。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>增加一个 <code>explain</code> 参数会为每个匹配到的文档产生一大堆额外内容，但是花时间去理解它是很有意义的。 如果现在看不明白也没关系&#8201;&#8212;&#8201;等你需要的时候再来回顾这一节就行。下面我们来一点点的了解这块知识点。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先，我们看一下普通查询返回的元数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "_index" :      "us",
    "_type" :       "tweet",
    "_id" :         "12",
    "_score" :      0.076713204,
    "_source" :     { ... trimmed ... },</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里加入了该文档来自于哪个节点哪个分片上的信息，这对我们是比较有帮助的，因为词频率和 文档频率是在每个分片中计算出来的，而不是每个索引中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">    "_shard" :      1,
    "_node" :       "mzIVYCsqSWCG_M_ZffSs9Q",</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后它提供了 <code>_explanation</code> 。每个入口都包含一个 <code>description</code> 、 <code>value</code>  、 <code>details</code> 字段，它分别告诉你计算的类型、计算结果和任何我们需要的计算细节。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"_explanation": { <b class="conum">(1)</b>
   "description": "weight(tweet:honeymoon in 0)
                  [PerFieldSimilarity], result of:",
   "value":       0.076713204,
   "details": [
      {
         "description": "fieldWeight in 0, product of:",
         "value":       0.076713204,
         "details": [
            {  <b class="conum">(2)</b>
               "description": "tf(freq=1.0), with freq of:",
               "value":       1,
               "details": [
                  {
                     "description": "termFreq=1.0",
                     "value":       1
                  }
               ]
            },
            { <b class="conum">(3)</b>
               "description": "idf(docFreq=1, maxDocs=1)",
               "value":       0.30685282
            },
            { <b class="conum">(4)</b>
               "description": "fieldNorm(doc=0)",
               "value":        0.25,
            }
         ]
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>honeymoon</code> 相关性评分计算的总结</p>
</li>
<li>
<p>检索词频率</p>
</li>
<li>
<p>反向文档频率</p>
</li>
<li>
<p>字段长度准则</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
输出 <code>explain</code> 结果代价是十分昂贵的，它只能用作调试工具 。千万不要用于生产环境。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第一部分是关于计算的总结。告诉了我们 <code>honeymoon</code> 在 <code>tweet</code> 字段中的检索词频率/反向文档频率或TF/IDF，
（这里的文档 <code>0</code> 是一个内部的 ID，跟我们没有关系，可以忽略。）</p>
</div>
<div class="paragraph">
<p>然后它提供了权重是如何计算的细节：</p>
</div>
<div class="paragraph">
<p>检索词频率:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>检索词 `honeymoon` 在这个文档的 `tweet` 字段中的出现次数。</pre>
</div>
</div>
<div class="paragraph">
<p>反向文档频率:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>检索词 `honeymoon` 在索引上所有文档的 `tweet` 字段中出现的次数。</pre>
</div>
</div>
<div class="paragraph">
<p>字段长度准则:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>在这个文档中， `tweet` 字段内容的长度 -- 内容越长，值越小。</pre>
</div>
</div>
<div class="paragraph">
<p>复杂的查询语句解释也非常复杂，但是包含的内容与上面例子大致相同。
通过这段信息我们可以了解搜索结果是如何产生的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>JSON 形式的 <code>explain</code> 描述是难以阅读的，
但是转成 YAML 会好很多，只需要在参数中加上 <code>format=yaml</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="explain-api">理解文档是如何被匹配到的</h4>
<div class="paragraph">
<p>当 <code>explain</code> 选项加到某一文档上时， <code>explain</code> api 会帮助你理解为何这个文档会被匹配，更重要的是，一个文档为何没有被匹配。
</p>
</div>
<div class="paragraph">
<p>请求路径为 <code>/index/type/id/_explain</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /us/tweet/12/_explain
{
   "query" : {
      "bool" : {
         "filter" : { "term" :  { "user_id" : 2           }},
         "must" :  { "match" : { "tweet" :   "honeymoon" }}
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不只是我们之前看到的充分解释 ，我们现在有了一个 <code>description</code> 元素，它将告诉我们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"failure to match filter: cache(user_id:[2 TO 2])"</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说我们的 <code>user_id</code> 过滤子句使该文档不能匹配到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docvalues-intro">Doc Values 介绍</h3>
<div class="paragraph">
<p>本章的最后一个话题是关于 <code>Elasticsearch</code> 内部的一些运行情况。在这里我们先不介绍新的知识点，所以我们应该意识到，<code>Doc Values</code> 是我们需要反复提到的一个重要话题。</p>
</div>
<div class="paragraph">
<p>当你对一个字段进行排序时，<code>Elasticsearch</code> 需要访问每个匹配到的文档得到相关的值。倒排索引的检索性能是非常快的，但是在字段值排序时却不是理想的结构。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在搜索的时候，我们能通过搜索关键词快速得到结果集。</p>
</li>
<li>
<p>当排序的时候，我们需要倒排索引里面某个字段值的集合。换句话说，我们需要 <code>转置</code> 倒排索引。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>转置</code> 结构在其他系统中经常被称作 <code>列存储</code> 。实质上，它将所有单字段的值存储在单数据列中，这使得对其进行操作是十分高效的，例如排序。</p>
</div>
<div class="paragraph">
<p>在 <code>Elasticsearch</code> 中，<code>Doc Values</code> 就是一种列式存储结构，默认情况下每个字段的 <code>Doc Values</code> 都是激活的，<code>Doc Values</code> 是在索引时创建的，当字段索引时，<code>Elasticsearch</code> 为了能够快速检索，会把字段的值加入倒排索引中，同时它也会存储该字段的 <code>Doc Values</code>。</p>
</div>
<div class="paragraph">
<p><code>Elasticsearch</code> 中的 <code>Doc Values</code> 常被应用到以下场景：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对一个字段进行排序</p>
</li>
<li>
<p>对一个字段进行聚合</p>
</li>
<li>
<p>某些过滤，比如地理位置过滤</p>
</li>
<li>
<p>某些与字段相关的脚本计算</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因为文档值被序列化到磁盘，我们可以依靠操作系统的帮助来快速访问。当 <code>working set</code> 远小于节点的可用内存，系统会自动将所有的文档值保存在内存中，使得其读写十分高速；
当其远大于可用内存，操作系统会自动把 <code>Doc Values</code> 加载到系统的页缓存中，从而避免了 <code>jvm</code> 堆内存溢出异常。</p>
</div>
<div class="paragraph">
<p>我们稍后会深入讨论 <code>Doc Values</code>。现在所有你需要知道的是排序发生在索引时建立的平行数据结构中。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-search">执行分布式检索</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在继续之前，我们将绕道讨论一下在分布式环境中搜索是怎么执行的。
 这比我们在 <a href="#distributed-docs">分布式文档存储</a> 章节讨论的基本的 <em>增-删-改-查</em> (CRUD)请求要复杂一些。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">内容提示</div>
<div class="paragraph">
<p>你可以根据兴趣阅读本章内容。你并不需要为了使用 Elasticsearch 而理解和记住所有的细节。</p>
</div>
<div class="paragraph">
<p>这章的阅读目的只为初步了解下工作原理，以便将来需要时可以及时找到这些知识，
但是不要被细节所困扰。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>一个 CRUD 操作只对单个文档进行处理，文档的唯一性由 <code>_index</code>, <code>_type</code>,
和 <a href="#routing-value"><code>routing</code> values</a> （通常默认是该文档的 <code>_id</code> ）的组合来确定。
这表示我们确切的知道集群中哪个分片含有此文档。</p>
</div>
<div class="paragraph">
<p>搜索需要一种更加复杂的执行模型因为我们不知道查询会命中哪些文档: 这些文档有可能在集群的任何分片上。
一个搜索请求必须询问我们关注的索引（index or indices）的所有分片的某个副本来确定它们是否含有任何匹配的文档。</p>
</div>
<div class="paragraph">
<p>但是找到所有的匹配文档仅仅完成事情的一半。
在 <code>search</code> 接口返回一个 <code>page</code> 结果之前，多分片中的结果必须组合成单个排序列表。
为此，搜索被执行成一个两阶段过程，我们称之为 <em>query then fetch</em> 。</p>
</div>
<div class="sect2">
<h3 id="_query_phase">查询阶段</h3>
<div class="paragraph">
<p>在初始 <em>查询阶段</em> 时， 查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。
每个分片在本地执行搜索并构建一个匹配文档的 <em>优先队列</em>。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">优先队列</div>
<div class="paragraph">
<p>一个 <em>优先队列</em> 仅仅是一个存有 <em>top-n</em> 匹配文档的有序列表。优先队列的大小取决于分页参数 <code>from</code> 和 <code>size</code> 。例如，如下搜索请求将需要足够大的优先队列来放入100条文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "from": 90,
    "size": 10
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个查询阶段的过程如图 <a href="#img-distrib-search">查询过程分布式搜索</a> 所示。</p>
</div>
<div id="img-distrib-search" class="imageblock">
<div class="content">
<img src="images/elas_0901.png" alt="查询过程分布式搜索">
</div>
<div class="title">Figure 14. 查询过程分布式搜索</div>
</div>
<div class="paragraph">
<p>查询阶段包含以下三个步骤:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端发送一个 <code>search</code> 请求到 <code>Node 3</code> ， <code>Node 3</code> 会创建一个大小为 <code>from + size</code> 的空优先队列。</p>
</li>
<li>
<p><code>Node 3</code> 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 <code>from + size</code> 的本地有序优先队列中。</p>
</li>
<li>
<p>每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 <code>Node 3</code> ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当一个搜索请求被发送到某个节点时，这个节点就变成了协调节点。 
这个节点的任务是广播查询请求到所有相关分片并将它们的响应整合成全局排序后的结果集合，这个结果集合会返回给客户端。</p>
</div>
<div class="paragraph">
<p>第一步是广播请求到索引中每一个节点的分片拷贝。就像 <a href="#distrib-read">document <code>GET</code> requests</a> 所描述的，
查询请求可以被某个主分片或某个副本分片处理， 这就是为什么更多的副本（当结合更多的硬件）能够增加搜索吞吐率。
协调节点将在之后的请求中轮询所有的分片拷贝来分摊负载。</p>
</div>
<div class="paragraph">
<p>每个分片在本地执行查询请求并且创建一个长度为 <code>from + size</code> 的优先队列&#x2014;也就是说，每个分片创建的结果集足够大，均可以满足全局的搜索请求。
分片返回一个轻量级的结果列表到协调节点，它仅包含文档 ID 集合以及任何排序需要用到的值，例如 <code>_score</code> 。</p>
</div>
<div class="paragraph">
<p>协调节点将这些分片级的结果合并到自己的有序优先队列里，它代表了全局排序结果集合。至此查询过程结束。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>一个索引可以由一个或几个主分片组成， 所以一个针对单个索引的搜索请求需要能够把来自多个分片的结果组合起来。
针对 <em>multiple</em> 或者 <em>all</em> 索引的搜索工作方式也是完全一致的&#8212;&#8203;仅仅是包含了更多的分片而已。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_fetch_phase">取回阶段</h3>
<div class="paragraph">
<p>查询阶段标识哪些文档满足搜索请求，但是我们仍然需要取回这些文档。这是取回阶段的任务, 正如 <a href="#img-distrib-fetch">分布式搜索的取回阶段</a> 所展示的。</p>
</div>
<div id="img-distrib-fetch" class="imageblock">
<div class="content">
<img src="images/elas_0902.png" alt="分布式搜索的取回阶段">
</div>
<div class="title">Figure 15. 分布式搜索的取回阶段</div>
</div>
<div class="paragraph">
<p>分布式阶段由以下步骤构成：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 <code>GET</code> 请求。</p>
</li>
<li>
<p>每个分片加载并 <em>丰富</em> 文档，如果有需要的话，接着返回文档给协调节点。</p>
</li>
<li>
<p>一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>协调节点首先决定哪些文档 <em>确实</em> 需要被取回。例如，如果我们的查询指定了 <code>{ "from": 90, "size": 10 }</code> ，最初的90个结果会被丢弃，只有从第91个开始的10个结果需要被取回。这些文档可能来自和最初搜索请求有关的一个、多个甚至全部分片。</p>
</div>
<div class="paragraph">
<p>协调节点给持有相关文档的每个分片创建一个 <a href="#distrib-multi-doc">multi-get request</a> ，并发送请求给同样处理查询阶段的分片副本。</p>
</div>
<div class="paragraph">
<p>分片加载文档体-- <code>_source</code> 字段&#8212;&#8203;如果有需要，用元数据和 <a href="#highlighting-intro">search snippet highlighting</a> 丰富结果文档。
一旦协调节点接收到所有的结果文档，它就组装这些结果为单个响应返回给客户端。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">深分页（Deep Pagination）</div>
<div class="paragraph">
<p>先查后取的过程支持用 <code>from</code> 和 <code>size</code> 参数分页，但是这是 <em>有限制的</em> 。 要记住需要传递信息给协调节点的每个分片必须先创建一个 <code>from + size</code> 长度的队列，协调节点需要根据 <code>number_of_shards * (from + size)</code> 排序文档，来找到被包含在 <code>size</code> 里的文档。</p>
</div>
<div class="paragraph">
<p>取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。但是使用足够大的 <code>from</code> 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。</p>
</div>
<div class="paragraph">
<p>实际上， ``深分页'' 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web spider。</p>
</div>
<div class="paragraph">
<p>如果你 <em>确实</em> 需要从你的集群取回大量的文档，你可以通过用 <code>scroll</code> 查询禁用排序使这个取回行为更有效率，我们会在 <a href="#scroll">later in this chapter</a> 进行讨论。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_search_options">搜索选项</h3>
<div class="paragraph">
<p>有几个  查询参数可以影响搜索过程。</p>
</div>
<div class="sect3">
<h4 id="_偏好">偏好</h4>
<div class="paragraph">
<p>偏好这个参数 <code>preference</code> 允许  用来控制由哪些分片或节点来处理搜索请求。 它接受像 <code>_primary</code>,
<code>_primary_first</code>, <code>_local</code>, <code>_only_node:xyz</code>, <code>_prefer_node:xyz</code>, 和
<code>_shards:2,3</code> 这样的值, 这些值在
{ref}/search-request-preference.html[search <code>preference</code>]
文档页面被详细解释。</p>
</div>
<div class="paragraph">
<p>但是最有用的值是某些随机字符串，它可以避免 <em>bouncing results</em> 问题。 </p>
</div>
<div id="bouncing-results" class="sidebarblock">
<div class="content">
<div class="title">Bouncing Results</div>
<div class="paragraph">
<p>想象一下有两个文档有同样值的时间戳字段，搜索结果用 <code>timestamp</code> 字段来排序。
由于搜索请求是在所有有效的分片副本间轮询的，那就有可能发生主分片处理请求时，这两个文档是一种顺序，
而副本分片处理请求时又是另一种顺序。</p>
</div>
<div class="paragraph">
<p>这就是所谓的 <em>bouncing results</em> 问题: 每次用户刷新页面，搜索结果表现是不同的顺序。
让同一个用户始终使用同一个分片，这样可以避免这种问题，
可以设置 <code>preference</code> 参数为一个特定的任意值比如用户会话ID来解决。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_超时问题">超时问题</h4>
<div class="paragraph">
<p>通常分片处理完它所有的数据后再把结果返回给协同节点，协同节点把收到的所有结果合并为最终结果。</p>
</div>
<div class="paragraph">
<p>这意味着花费的时间是最慢分片的处理时间加结果合并的时间。如果有一个节点有问题，就会导致所有的响应缓慢。</p>
</div>
<div class="paragraph">
<p>参数 <code>timeout</code> 告诉  分片允许处理数据的最大时间。如果没有足够的时间处理所有数据，这个分片的结果可以是部分的，甚至是空数据。</p>
</div>
<div class="paragraph">
<p>搜索的返回结果会用属性 <code>timed_out</code> 标明分片是否返回的是部分结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">    ...
    "timed_out":     true,  <b class="conum">(1)</b>
    ...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>这个搜索请求超时了。</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>超时仍然是一个最有效的操作，知道这一点很重要； 很可能查询会超过设定的超时时间。这种行为有两个原因：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>超时检查是基于每文档做的。 但是某些查询类型有大量的工作在文档评估之前需要完成。 这种 "setup" 阶段并不考虑超时设置，所以太长的建立时间会导致超过超时时间的整体延迟。</p>
</li>
<li>
<p>因为时间检查是基于每个文档的，一次长时间查询在单个文档上执行并且在下个文档被评估之前不会超时。 这也意味着差的脚本（比如带无限循环的脚本）将会永远执行下去。</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="search-routing">路由</h4>
<div class="paragraph">
<p>在 <a href="#routing-value">路由一个文档到一个分片中</a> 中, 我们解释过如何定制参数 <code>routing</code> 
，它能够在索引时提供来确保相关的文档，比如属于某个用户的文档被存储在某个分片上。
在搜索的时候，不用搜索索引的所有分片，而是通过指定几个 <code>routing</code> 值来限定只搜索几个相关的分片：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?routing=user_1,user2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个技术在设计大规模搜索系统时就会派上用场，我们在 <a href="#scale">[scale]</a> 中详细讨论它。</p>
</div>
</div>
<div class="sect3">
<h4 id="search-type">搜索类型</h4>
<div class="paragraph">
<p>缺省的搜索类型是 <code>query_then_fetch</code> 。 在某些情况下，你可能想明确设置 <code>search_type</code> 为 <code>dfs_query_then_fetch</code> 来改善相关性精确度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search?search_type=dfs_query_then_fetch</code></pre>
</div>
</div>
<div class="paragraph">
<p>搜索类型 <code>dfs_query_then_fetch</code> 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。
我们在 <a href="#relevance-is-broken">[relevance-is-broken]</a> 会再讨论它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scroll">游标查询 'Scroll'</h3>
<div class="paragraph">
<p><code>scroll</code> 查询   可以用来对 Elasticsearch 有效地执行大批量的文档查询，而又不用付出深度分页那种代价。</p>
</div>
<div class="paragraph">
<p>游标查询允许我们  先做查询初始化，然后再批量地拉取结果。
这有点儿像传统数据库中的 <em>cursor</em>   。</p>
</div>
<div class="paragraph">
<p>游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。
它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 '视图' 一样。</p>
</div>
<div class="paragraph">
<p>深度分页的代价根源是结果集全局排序，如果去掉全局排序的特性的话查询结果的成本就会很低。
游标查询用字段 <code>_doc</code> 来排序。 这个指令让 Elasticsearch 仅仅从还有结果的分片返回下一批结果。</p>
</div>
<div class="paragraph">
<p>启用游标查询可以通过在查询的时候设置参数 <code>scroll</code> 的值为我们期望的游标查询的过期时间。
游标查询的过期时间会在每次做查询的时候刷新，所以这个时间只需要足够处理当前批的结果就可以了，而不是处理查询结果的所有文档的所需时间。
这个过期时间的参数很重要，因为保持这个游标查询窗口需要消耗资源，所以我们期望如果不再需要维护这种资源就该早点儿释放掉。
设置这个超时能够让 Elasticsearch 在稍后空闲的时候自动释放这部分资源。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /old_index/_search?scroll=1m <b class="conum">(1)</b>
{
    "query": { "match_all": {}},
    "sort" : ["_doc"], <b class="conum">(2)</b>
    "size":  1000
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>保持游标查询窗口一分钟。</p>
</li>
<li>
<p>关键字 <code>_doc</code> 是最有效的排序顺序。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这个查询的返回结果包括一个字段 <code>_scroll_id</code>， 它是一个base64编码的长字符串  。 现在我们能传递字段
<code>_scroll_id</code> 到 <code>_search/scroll</code> 查询接口获取下一批结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search/scroll
{
    "scroll": "1m", <b class="conum">(1)</b>
    "scroll_id" : "cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs="
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>注意再次设置游标查询过期时间为一分钟。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这个游标查询返回的下一批结果。
尽管我们指定字段 <code>size</code> 的值为1000，我们有可能取到超过这个值数量的文档。
   当查询的时候， 字段 <code>size</code> 作用于单个分片，所以每个批次实际返回的文档数量最大为
 <code>size * number_of_primary_shards</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
注意游标查询每次返回一个新字段 <code>_scroll_id</code>。每次我们做下一次游标查询，
 我们必须把前一次查询返回的字段 <code>_scroll_id</code> 传递进去。 当没有更多的结果返回的时候，我们就处理完所有匹配的文档了。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
提示：某些官方的 Elasticsearch 客户端比如
<a href="http://elasticsearch-py.readthedocs.org/en/master/helpers.html#scan">Python 客户端</a> 和
<a href="https://metacpan.org/pod/Search::Elasticsearch::Scroll">Perl 客户端</a> 提供了这个功能易用的封装。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="index-management">索引管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们已经看到 Elasticsearch 让开发一个新的应用变得简单，不需要任何预先计划或设置。
不过，要不了多久你就会开始想要优化索引和搜索过程，以便更好地适合您的特定用例。
这些定制几乎围绕着索引和类型的方方面面，在本章，我们将介绍管理索引和类型映射的 API 以及一些最重要的设置。</p>
</div>
<div class="sect2">
<h3 id="_creating_an_index">创建一个索引</h3>
<div class="paragraph">
<p>到目前为止, 我们已经通过索引一篇文档创建了一个新的索引  。这个索引采用的是默认的配置，新的字段通过动态映射的方式被添加到类型映射。现在我们需要对这个建立索引的过程做更多的控制：我们想要确保这个索引有数量适中的主分片，并且在我们索引任何数据 <em>之前</em> ，分析器和映射已经被建立好。</p>
</div>
<div class="paragraph">
<p>为了达到这个目的，我们需要手动创建索引，在请求体里面传入设置或类型映射，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "settings": { ... any settings ... },
    "mappings": {
        "type_one": { ... any mappings ... },
        "type_two": { ... any mappings ... },
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想禁止自动创建索引，你  可以通过在 <code>config/elasticsearch.yml</code> 的每个节点下添加下面的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">action.auto_create_index: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>我们会在之后讨论你怎么用 <a href="#index-templates">[index-templates]</a> 来预配置开启自动创建索引。这在索引日志数据的时候尤其有用：你将日志数据索引在一个以日期结尾命名的索引上，子夜时分，一个预配置的新索引将会自动进行创建。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_an_index">删除一个索引</h3>
<div class="paragraph">
<p>用以下的请求来  删除索引:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /my_index</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以这样删除多个索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /index_one,index_two
DELETE /index_*</code></pre>
</div>
</div>
<div class="paragraph">
<p>你甚至可以这样删除 <em>全部</em> 索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">DELETE /_all
DELETE /*</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>对一些人来说，能够用单个命令来删除所有数据可能会导致可怕的后果。如果你想要避免意外的大量删除, 你可以在你的 <code>elasticsearch.yml</code> 做如下配置：</p>
</div>
<div class="paragraph">
<p><code>action.destructive_requires_name: true</code></p>
</div>
<div class="paragraph">
<p>这个设置使删除只限于特定名称指向的数据, 而不允许通过指定 <code>_all</code> 或通配符来删除指定索引库。你同样可以通过 <a href="#_changing_settings_dynamically">Cluster State API</a> 动态的更新这个设置。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="index-settings">索引设置</h3>
<div class="paragraph">
<p>你可以通过修改配置来自定义索引行为，详细配置参照
{ref}/index-modules.html[索引模块]</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Elasticsearch 提供了优化好的默认配置。 除非你理解这些配置的作用并且知道为什么要去修改，否则不要随意修改。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是两个 最重要的设置：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>number_of_shards</code></dt>
<dd>
<p>每个索引的主分片数，默认值是 <code>5</code> 。这个配置在索引创建后不能修改。</p>
</dd>
<dt class="hdlist1"><code>number_of_replicas</code></dt>
<dd>
<p>每个主分片的副本数，默认值是 <code>1</code> 。对于活动的索引库，这个配置可以随时修改。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>例如，我们可以创建只有 一个主分片，没有副本的小索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_temp_index
{
    "settings": {
        "number_of_shards" :   1,
        "number_of_replicas" : 0
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以用
<code>update-index-settings</code> API  动态修改副本数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_temp_index/_settings
{
    "number_of_replicas": 1
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-analyzers">配置分析器</h3>
<div class="paragraph">
<p>第三个重要的索引设置是 <code>analysis</code> 部分，用来配置已存在的分析器或针对你的索引创建新的自定义分析器。</p>
</div>
<div class="paragraph">
<p>在 <a href="#analysis-intro">分析与分析器</a> ，我们介绍了一些内置的分析器，用于将全文字符串转换为适合搜索的倒排索引。</p>
</div>
<div class="paragraph">
<p><code>standard</code> 分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。

它包括了以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>standard</code> 分词器，通过单词边界分割输入的文本。</p>
</li>
<li>
<p><code>standard</code> 语汇单元过滤器，目的是整理分词器触发的语汇单元（但是目前什么都没做）。</p>
</li>
<li>
<p><code>lowercase</code> 语汇单元过滤器，转换所有的语汇单元为小写。</p>
</li>
<li>
<p><code>stop</code> 语汇单元过滤器，删除停用词&#8212;&#8203;对搜索相关性影响不大的常用词，如 <code>a</code> ， <code>the</code> ， <code>and</code> ， <code>is</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，停用词过滤器是被禁用的。如需启用它，你可以通过创建一个基于 <code>standard</code> 分析器的自定义分析器并设置 <code>stopwords</code> 参数。
 可以给分析器提供一个停用词列表，或者告知使用一个基于特定语言的预定义停用词列表。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，我们创建了一个新的分析器，叫做 <code>es_std</code> ，
并使用预定义的西班牙语停用词列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /spanish_docs
{
    "settings": {
        "analysis": {
            "analyzer": {
                "es_std": {
                    "type":      "standard",
                    "stopwords": "_spanish_"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>es_std</code> 分析器不是全局的&#8212;&#8203;它仅仅存在于我们定义的 <code>spanish_docs</code> 索引中。
为了使用 <code>analyze</code> API来对它进行测试，我们必须使用特定的索引名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /spanish_docs/_analyze?analyzer=es_std
El veloz zorro marrón</code></pre>
</div>
</div>
<div class="paragraph">
<p>简化的结果显示西班牙语停用词 <code>El</code> 已被正确的移除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "tokens" : [
    { "token" :    "veloz",   "position" : 2 },
    { "token" :    "zorro",   "position" : 3 },
    { "token" :    "marrón",  "position" : 4 }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="custom-analyzers">自定义分析器</h3>
<div class="paragraph">
<p>虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p>
</div>
<div class="paragraph">
<p>在 <a href="#analysis-intro">分析与分析器</a> 我们说过，一个 <em>分析器</em> 就是在一个包里面组合了三种函数的一个包装器，  三种函数按照顺序被执行:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">字符过滤器</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>字符过滤器  用来 <code>整理</code> 一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像 <code>&lt;p&gt;</code> 或者 <code>&lt;div&gt;</code> 这样的HTML标签，这些标签是我们不想索引的。我们可以使用 {ref}/analysis-htmlstrip-charfilter.html[<code>html清除</code> 字符过滤器] 来移除掉所有的HTML标签，并且像把 <code>&Aacute;</code> 转换为相对应的Unicode字符 <code>Á</code>  这样，转换HTML实体。</p>
</div>
<div class="paragraph">
<p>一个分析器可能有0个或者多个字符过滤器。</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">分词器</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>一个分析器 <em>必须</em> 有一个唯一的分词器。  分词器把字符串分解成单个词条或者词汇单元。 <code>标准</code> 分析器里使用的 {ref}/analysis-standard-tokenizer.html[<code>标准</code> 分词器]   把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p>
</div>
<div class="paragraph">
<p>例如， {ref}/analysis-keyword-tokenizer.html[<code>关键词</code> 分词器] 完整地输出  接收到的同样的字符串，并不做任何分词。 {ref}/analysis-whitespace-tokenizer.html[<code>空格</code> 分词器] 只根据空格分割文本  。 {ref}/analysis-pattern-tokenizer.html[<code>正则</code> 分词器] 根据匹配正则表达式来分割文本  。</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">词单元过滤器</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>经过分词，作为结果的 <em>词单元流</em> 会按照指定的顺序通过指定的词单元过滤器  。</p>
</div>
<div class="paragraph">
<p>词单元过滤器可以修改、添加或者移除词单元。我们已经提到过 <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenizer.html"> <code>lowercase</code> </a> 和  {ref}/analysis-stop-tokenfilter.html[ <code>stop</code> 词过滤器] ，但是在 Elasticsearch 里面还有很多可供选择的词单元过滤器。 {ref}/analysis-stemmer-tokenfilter.html[词干过滤器] 把单词 <code>遏制</code> 为  词干。 {ref}/analysis-asciifolding-tokenfilter.html[ <code>ascii_folding</code> 过滤器]移除变音符，把一个像 <code>"très"</code> 这样的词转换为 <code>"tres"</code> 。 {ref}/analysis-ngram-tokenfilter.html[<code>ngram</code>] 和 {ref}/analysis-edgengram-tokenfilter.html[ <code>edge_ngram</code> 词单元过滤器] 可以产生  适合用于部分匹配或者自动补全的词单元。</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在 <a href="#search-in-depth">[search-in-depth]</a>，我们讨论了在哪里使用，以及怎样使用分词器和过滤器。但是首先，我们需要解释一下怎样创建自定义的分析器。</p>
</div>
<div class="sect3">
<h4 id="_创建一个自定义分析器">创建一个自定义分析器</h4>
<div class="paragraph">
<p>和我们之前配置 <code>es_std</code> 分析器一样，我们可以在 <code>analysis</code> 下的相应位置设置字符过滤器、分词器和词单元过滤器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "settings": {
        "analysis": {
            "char_filter": { ... custom character filters ... },
            "tokenizer":   { ...    custom tokenizers     ... },
            "filter":      { ...   custom token filters   ... },
            "analyzer":    { ...    custom analyzers      ... }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为示范，让我们一起来创建一个自定义分析器吧，这个分析器可以做到下面的这些事:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用 <code>html清除</code> 字符过滤器移除HTML部分。</p>
</li>
<li>
<p>使用一个自定义的 <code>映射</code> 字符过滤器把 <code>&amp;</code> 替换为 <code>" and "</code> ：</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"char_filter": {
    "&amp;_to_and": {
        "type":       "mapping",
        "mappings": [ "&amp;=&gt; and "]
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>使用 <code>标准</code> 分词器分词。</p>
</li>
<li>
<p>小写词条，使用 <code>小写</code> 词过滤器处理。</p>
</li>
<li>
<p>使用自定义 <code>停止</code> 词过滤器移除自定义的停止词列表中包含的词：</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"filter": {
    "my_stopwords": {
        "type":        "stop",
        "stopwords": [ "the", "a" ]
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们的分析器定义用我们之前已经设置好的自定义过滤器组合了已经定义好的分词器和过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"analyzer": {
    "my_analyzer": {
        "type":           "custom",
        "char_filter":  [ "html_strip", "&amp;_to_and" ],
        "tokenizer":      "standard",
        "filter":       [ "lowercase", "my_stopwords" ]
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>汇总起来，完整的 <code>创建索引</code> 请求  看起来应该像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "settings": {
        "analysis": {
            "char_filter": {
                "&amp;_to_and": {
                    "type":       "mapping",
                    "mappings": [ "&amp;=&gt; and "]
            }},
            "filter": {
                "my_stopwords": {
                    "type":       "stop",
                    "stopwords": [ "the", "a" ]
            }},
            "analyzer": {
                "my_analyzer": {
                    "type":         "custom",
                    "char_filter":  [ "html_strip", "&amp;_to_and" ],
                    "tokenizer":    "standard",
                    "filter":       [ "lowercase", "my_stopwords" ]
            }}
}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>索引被创建以后，使用 <code>analyze</code> API 来  测试这个新的分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index/_analyze?analyzer=my_analyzer
The quick &amp; brown fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的缩略结果展示出我们的分析器正在正确地运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "tokens" : [
      { "token" :   "quick",    "position" : 2 },
      { "token" :   "and",      "position" : 3 },
      { "token" :   "brown",    "position" : 4 },
      { "token" :   "fox",      "position" : 5 }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个分析器现在是没有多大用处的，除非我们告诉  Elasticsearch在哪里用上它。我们可以像下面这样把这个分析器应用在一个 <code>string</code> 字段上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/_mapping/my_type
{
    "properties": {
        "title": {
            "type":      "string",
            "analyzer":  "my_analyzer"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping">类型和映射</h3>
<div class="paragraph">
<p><em>类型</em> 在 Elasticsearch 中表示一类相似的文档。 类型由 <em>名称</em> &#x2014;比如 <code>user</code> 或 <code>blogpost</code> &#x2014;和 <em>映射</em> 组成。</p>
</div>
<div class="paragraph">
<p><em>映射</em>, 就像数据库中的 schema ，描述了文档可能具有的字段或 <em>属性</em>  、每个字段的数据类型&#x2014;比如 <code>string</code>,
<code>integer</code> 或 <code>date</code> &#x2014;以及Lucene是如何索引和存储这些字段的。</p>
</div>
<div class="paragraph">
<p>类型可以很好的抽象划分相似但不相同的数据。但由于 Lucene 的处理方式，类型的使用有些限制。</p>
</div>
<div class="sect3">
<h4 id="_lucene_如何处理文档">Lucene 如何处理文档</h4>
<div class="paragraph">
<p>在 Lucene 中，一个文档由一组简单的键值对组成。 每个字段都可以有多个值，但至少要有一个值。
类似的，一个字符串可以通过分析过程转化为多个值。Lucene 不关心这些值是字符串、数字或日期&#8212;&#8203;所有的值都被当做 <em>不透明字节</em> 。</p>
</div>
<div class="paragraph">
<p>当我们在 Lucene 中索引一个文档时，每个字段的值都被添加到相关字段的倒排索引中。你也可以将未处理的原始数据 <em>存储</em> 起来，以便这些原始数据在之后也可以被检索到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类型是如何实现的">类型是如何实现的</h4>
<div class="paragraph">
<p>Elasticsearch 类型是以 Lucene 处理文档的这个方式为基础来实现的。一个索引可以有多个类型，这些类型的文档可以存储在相同的索引中。</p>
</div>
<div class="paragraph">
<p>Lucene 没有文档类型的概念，每个文档的类型名被存储在一个叫 <code>_type</code> 的元数据字段上。 当我们要检索某个类型的文档时, Elasticsearch 通过在 <code>_type</code> 字段上使用过滤器限制只返回这个类型的文档。</p>
</div>
<div class="paragraph">
<p>Lucene 也没有映射的概念。 映射是 Elasticsearch 将复杂 JSON 文档 <em>映射</em> 成 Lucene 需要的扁平化数据的方式。</p>
</div>
<div class="paragraph">
<p>例如，在 <code>user</code> 类型中， <code>name</code> 字段的映射可以声明这个字段是 <code>string</code> 类型，并且它的值被索引到名叫 <code>name</code> 的倒排索引之前，需要通过 <code>whitespace</code> 分词器分析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"name": {
    "type":     "string",
    "analyzer": "whitespace"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_避免类型陷阱">避免类型陷阱</h4>
<div class="paragraph">
<p>这导致了一个有趣的思想实验： 如果有两个不同的类型，每个类型都有同名的字段，但映射不同（例如：一个是字符串一个是数字），将会出现什么情况？</p>
</div>
<div class="paragraph">
<p>简单回答是，Elasticsearch 不会允许你定义这个映射。当你配置这个映射时，将会出现异常。</p>
</div>
<div class="paragraph">
<p>详细回答是，每个 Lucene 索引中的所有字段都包含一个单一的、扁平的模式。一个特定字段可以映射成 string 类型也可以是 number 类型，但是不能两者兼具。因为类型是 Elasticsearch 添加的 <em>优于</em> Lucene 的额外机制（以元数据 <code>_type</code> 字段的形式），在 Elasticsearch 中的所有类型最终都共享相同的映射。</p>
</div>
<div class="paragraph">
<p>以 <code>data</code> 索引中两种类型的映射为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "data": {
      "mappings": {
         "people": {
            "properties": {
               "name": {
                  "type": "string",
               },
               "address": {
                  "type": "string"
               }
            }
         },
         "transactions": {
            "properties": {
               "timestamp": {
                  "type": "date",
                  "format": "strict_date_optional_time"
               },
               "message": {
                  "type": "string"
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个类型定义两个字段 (分别是 <code>"name"</code>/<code>"address"</code> 和 <code>"timestamp"</code>/<code>"message"</code>
)。它们看起来是相互独立的，但在后台 Lucene 将创建一个映射，如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
   "data": {
      "mappings": {
        "_type": {
          "type": "string",
          "index": "not_analyzed"
        },
        "name": {
          "type": "string"
        }
        "address": {
          "type": "string"
        }
        "timestamp": {
          "type": "long"
        }
        "message": {
          "type": "string"
        }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>注: 这不是真实有效的映射语法，只是用于演示</em></p>
</div>
<div class="paragraph">
<p>对于整个索引，映射在本质上被 <em>扁平化</em> 成一个单一的、全局的模式。这就是为什么两个类型不能定义冲突的字段：当映射被扁平化时，Lucene 不知道如何去处理。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类型结论">类型结论</h4>
<div class="paragraph">
<p>那么，这个讨论的结论是什么？技术上讲，多个类型可以在相同的索引中存在，只要它们的字段不冲突（要么因为字段是互为独占模式，要么因为它们共享相同的字段）。</p>
</div>
<div class="paragraph">
<p>重要的一点是: 类型可以很好的区分同一个集合中的不同细分。在不同的细分中数据的整体模式是相同的（或相似的）。</p>
</div>
<div class="paragraph">
<p>类型不适合 <em>完全不同类型的数据</em> 。如果两个类型的字段集是互不相同的，这就意味着索引中将有一半的数据是空的（字段将是 <em>稀疏的</em> ），最终将导致性能问题。在这种情况下，最好是使用两个单独的索引。</p>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>正确:</strong> 将 <code>kitchen</code> 和 <code>lawn-care</code> 类型放在 <code>products</code> 索引中, 因为这两种类型基本上是相同的模式</p>
</li>
<li>
<p><strong>错误:</strong> 将 <code>products</code> 和 <code>logs</code> 类型放在 <code>data</code> 索引中, 因为这两种类型互不相同。应该将它们放在不同的索引中。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="root-object">根对象</h3>
<div class="paragraph">
<p>映射的最高一层被称为 <em>根对象</em> ，它可能包含下面几项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 <em>properties</em> 节点，列出了文档中可能包含的每个字段的映射</p>
</li>
<li>
<p>各种元数据字段，它们都以一个下划线开头，例如 <code>_type</code> 、 <code>_id</code> 和 <code>_source</code></p>
</li>
<li>
<p>设置项，控制如何动态处理新的字段，例如 <code>analyzer</code> 、 <code>dynamic_date_formats</code> 和
<code>dynamic_templates</code></p>
</li>
<li>
<p>其他设置，可以同时应用在根对象和其他 <code>object</code> 类型的字段上，例如 <code>enabled</code> 、 <code>dynamic</code> 和 <code>include_in_all</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_属性">属性</h4>
<div class="paragraph">
<p>我们已经在 <a href="#core-fields">核心简单域类型</a> 和 <a href="#complex-core-fields">复杂核心域类型</a> 章节中介绍过文档字段和属性的三个最重要的设置：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>字段的数据类型，例如 <code>string</code> 或 <code>date</code></p>
</dd>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>字段是否应当被当成全文来搜索（ <code>analyzed</code> ），或被当成一个准确的值（ <code>not_analyzed</code> ），还是完全不可被搜索（ <code>no</code> ）</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>确定在索引和搜索时全文字段使用的 <code>analyzer</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>我们将在本书的后续部分讨论其他字段类型，例如 <code>ip</code> 、 <code>geo_point</code> 和 <code>geo_shape</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="source-field">元数据: _source 字段</h4>
<div class="paragraph">
<p>默认地，Elasticsearch  在 <code>_source</code> 字段存储代表文档体的JSON字符串。和所有被存储的字段一样， <code>_source</code> 字段在被写入磁盘之前先会被压缩。</p>
</div>
<div class="paragraph">
<p>这个字段的存储几乎总是我们想要的，因为它意味着下面的这些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>搜索结果包括了整个可用的文档——不需要额外的从另一个的数据仓库来取文档。</p>
</li>
<li>
<p>如果没有 <code>_source</code> 字段，部分 <code>update</code> 请求不会生效。</p>
</li>
<li>
<p>当你的映射改变时，你需要重新索引你的数据，有了_source字段你可以直接从Elasticsearch这样做，而不必从另一个（通常是速度更慢的）数据仓库取回你的所有文档。</p>
</li>
<li>
<p>当你不需要看到整个文档时，单个字段可以从 <code>_source</code> 字段提取和通过 <code>get</code> 或者 <code>search</code> 请求返回。</p>
</li>
<li>
<p>调试查询语句更加简单，因为你可以直接看到每个文档包括什么，而不是从一列id猜测它们的内容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然而，存储 <code>_source</code> 字段的确要使用磁盘空间。如果上面的原因对你来说没有一个是重要的，你可以用下面的映射禁用 <code>_source</code> 字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "mappings": {
        "my_type": {
            "_source": {
                "enabled":  false
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个搜索请求里，你可以通过在请求体中指定 <code>_source</code> 参数，来达到只获取特定的字段的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "query":   { "match_all": {}},
    "_source": [ "title", "created" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些字段的值会从 <code>_source</code> 字段被提取和返回，而不是返回整个 <code>_source</code> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Stored Fields 被存储字段</div>
<div class="paragraph">
<p>为了之后的检索，除了索引一个字段的值，你  还可以选择 <code>存储</code> 原始字段值。有 Lucene 使用背景的用户使用被存储字段来选择他们想要在搜索结果里面返回的字段。事实上， <code>_source</code> 字段就是一个被存储的字段。</p>
</div>
<div class="paragraph">
<p>在Elasticsearch中，对文档的个别字段设置存储的做法通常不是最优的。整个文档已经被存储为 <code>_source</code> 字段。使用 <code>_source</code> 参数提取你需要的字段总是更好的。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="all-field">元数据: _all 字段</h4>
<div class="paragraph">
<p>在 <a href="#search-lite"><em>轻量</em> 搜索</a> 中，我们介绍了 <code>_all</code> 字段：一个把其它字段值当作一个大字符串来索引的特殊字段。 <code>query_string</code> 查询子句(搜索 <code>?q=john</code> )在没有指定字段时默认使用 <code>_all</code> 字段。</p>
</div>
<div class="paragraph">
<p><code>_all</code> 字段在新应用的探索阶段，当你还不清楚文档的最终结构时是比较有用的。你可以使用这个字段来做任何查询，并且有很大可能找到需要的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /_search
{
    "match": {
        "_all": "john smith marketing"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着应用的发展，搜索需求变得更加明确，你会发现自己越来越少使用 <code>_all</code> 字段。 <code>_all</code> 字段是搜索的应急之策。通过查询指定字段，你的查询更加灵活、强大，你也可以对相关性最高的搜索结果进行更细粒度的控制。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#relevance-intro">relevance algorithm</a> 考虑的一个最重要的原则是字段的长度：字段越短越重要。 在较短的 <code>title</code> 字段中出现的短语可能比在较长的 <code>content</code> 字段中出现的短语更加重要。字段长度的区别在 <code>_all</code> 字段中不会出现。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不再需要 <code>_all</code> 字段，你可以通过下面的映射来禁用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/_mapping/my_type
{
    "my_type": {
        "_all": { "enabled": false }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>include_in_all</code> 设置来逐个控制字段是否要包含在 <code>_all</code> 字段中，默认值是 <code>true</code>。在一个对象(或根对象)上设置 <code>include_in_all</code> 可以修改这个对象中的所有字段的默认行为。</p>
</div>
<div class="paragraph">
<p>你可能想要保留 <code>_all</code> 字段作为一个只包含某些特定字段的全文字段，例如只包含 <code>title</code>，<code>overview</code>，<code>summary</code> 和 <code>tags</code>。 相对于完全禁用 <code>_all</code> 字段，你可以为所有字段默认禁用 <code>include_in_all</code> 选项，仅在你选择的字段上启用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/my_type/_mapping
{
    "my_type": {
        "include_in_all": false,
        "properties": {
            "title": {
                "type":           "string",
                "include_in_all": true
            },
            ...
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住，<code>_all</code> 字段仅仅是一个 经过分词的 <code>string</code> 字段。它使用默认分词器来分析它的值，不管这个值原本所在字段指定的分词器。就像所有 <code>string</code> 字段，你可以配置 <code>_all</code> 字段使用的分词器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/my_type/_mapping
{
    "my_type": {
        "_all": { "analyzer": "whitespace" }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_metadata_document_identity">元数据：文档标识</h4>
<div class="paragraph">
<p>文档标识与四个元数据字段相关：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>文档的 ID 字符串</p>
</dd>
<dt class="hdlist1"><code>_type</code></dt>
<dd>
<p>文档的类型名</p>
</dd>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>文档所在的索引</p>
</dd>
<dt class="hdlist1"><code>_uid</code></dt>
<dd>
<p><code>_type</code> 和 <code>_id</code> 连接在一起构造成 <code>type#id</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>默认情况下， <code>_uid</code> 字段是被存储（可取回）和索引（可搜索）的。
<code>_type</code> 字段被索引但是没有存储，
<code>_id</code> 和 <code>_index</code> 字段则既没有被索引也没有被存储，这意味着它们并不是真实存在的。</p>
</div>
<div class="paragraph">
<p>尽管如此，你仍然可以像真实字段一样查询 <code>_id</code> 字段。Elasticsearch 使用 <code>_uid</code> 字段来派生出 <code>_id</code> 。
虽然你可以修改这些字段的 <code>index</code> 和 <code>store</code> 设置，但是基本上不需要这么做。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-mapping">动态映射</h3>
<div class="paragraph">
<p>当 Elasticsearch 遇到文档中以前  未遇到的字段，它用 <a href="#mapping-intro"><em>dynamic mapping</em></a> 来确定字段的数据类型并自动把新的字段添加到类型映射。</p>
</div>
<div class="paragraph">
<p>有时这是想要的行为有时又不希望这样。通常没有人知道以后会有什么新字段加到文档，但是又希望这些字段被自动的索引。也许你只想忽略它们。如果Elasticsearch是作为重要的数据存储，可能就会期望遇到新字段就会抛出异常，这样能及时发现问题。</p>
</div>
<div class="paragraph">
<p>幸运的是可以用 <code>dynamic</code> 配置来控制这种行为  ，可接受的选项如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>动态添加新的字段&#8212;&#8203;缺省</p>
</dd>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>忽略新的字段</p>
</dd>
<dt class="hdlist1"><code>strict</code></dt>
<dd>
<p>如果遇到新字段抛出异常</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>配置参数 <code>dynamic</code> 可以用在根 <code>object</code> 或任何 <code>object</code> 类型的字段上。你可以将 <code>dynamic</code> 的默认值设置为 <code>strict</code> , 而只在指定的内部对象中开启它, 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "mappings": {
        "my_type": {
            "dynamic":      "strict", <b class="conum">(1)</b>
            "properties": {
                "title":  { "type": "string"},
                "stash":  {
                    "type":     "object",
                    "dynamic":  true <b class="conum">(2)</b>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>如果遇到新字段，对象 <code>my_type</code> 就会抛出异常。</p>
</li>
<li>
<p>而内部对象 <code>stash</code> 遇到新字段就会动态创建新字段。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用上述动态映射， 你可以给 <code>stash</code> 对象添加新的可检索的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/my_type/1
{
    "title":   "This doc adds a new field",
    "stash": { "new_field": "Success!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是对根节点对象 <code>my_type</code> 进行同样的操作会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/my_type/1
{
    "title":     "This throws a StrictDynamicMappingException",
    "new_field": "Fail!"
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
把 <code>dynamic</code> 设置为 <code>false</code> 一点儿也不会改变 <code>_source</code> 的字段内容。 <code>_source</code> 仍然包含被索引的整个JSON文档。只是新的字段不会被加到映射中也不可搜索。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="custom-dynamic-mapping">自定义动态映射</h3>
<div class="paragraph">
<p>如果你想在运行时增加新的字段，你可能会启用动态映射。然而，有时候，动态映射 <code>规则</code> 可能不太智能。幸运的是，我们可以通过设置去自定义这些规则，以便更好的适用于你的数据。</p>
</div>
<div class="sect3">
<h4 id="date-detection">日期检测</h4>
<div class="paragraph">
<p>当 Elasticsearch 遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如 <code>2014-01-01</code> 。如果它像日期，这个字段就会被作为 <code>date</code> 类型添加。否则，它会被作为 <code>string</code> 类型添加。</p>
</div>
<div class="paragraph">
<p>有些时候这个行为可能导致一些问题。想象下，你有如下这样的一个文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "note": "2014-01-01" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设这是第一次识别 <code>note</code> 字段，它会被添加为 <code>date</code> 字段。但是如果下一个文档像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "note": "Logged out" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这显然不是一个日期，但为时已晚。这个字段已经是一个日期类型，这个 <code>不合法的日期</code> 将会造成一个异常。</p>
</div>
<div class="paragraph">
<p>日期检测可以通过在根对象上设置 <code>date_detection</code> 为 <code>false</code> 来关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "mappings": {
        "my_type": {
            "date_detection": false
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这个映射，字符串将始终作为 <code>string</code> 类型。如果你需要一个 <code>date</code> 字段，你必须手动添加。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Elasticsearch 判断字符串为日期的规则可以通过 {ref}/dynamic-field-mapping.html#date-detection[<code>dynamic_date_formats</code> setting] 来设置。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-templates">动态模板</h4>
<div class="paragraph">
<p>使用 <code>dynamic_templates</code> ，你可以完全控制新检测生成字段的映射。你甚至可以通过字段名称或数据类型来应用不同的映射。</p>
</div>
<div class="paragraph">
<p>每个模板都有一个名称，你可以用来描述这个模板的用途， 一个 <code>mapping</code> 来指定映射应该怎样使用，以及至少一个参数 (如 <code>match</code>) 来定义这个模板适用于哪个字段。</p>
</div>
<div class="paragraph">
<p>模板按照顺序来检测；第一个匹配的模板会被启用。例如，我们给 <code>string</code> 类型字段定义两个模板：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>es</code> ：以 <code>_es</code> 结尾的字段名需要使用 <code>spanish</code> 分词器。</p>
</li>
<li>
<p><code>en</code> ：所有其他字段使用 <code>english</code> 分词器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将 <code>es</code> 模板放在第一位，因为它比匹配所有字符串字段的 <code>en</code> 模板更特殊：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "mappings": {
        "my_type": {
            "dynamic_templates": [
                { "es": {
                      "match":              "*_es", <b class="conum">(1)</b>
                      "match_mapping_type": "string",
                      "mapping": {
                          "type":           "string",
                          "analyzer":       "spanish"
                      }
                }},
                { "en": {
                      "match":              "*", <b class="conum">(2)</b>
                      "match_mapping_type": "string",
                      "mapping": {
                          "type":           "string",
                          "analyzer":       "english"
                      }
                }}
            ]
}}}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>匹配字段名以 <code>_es</code> 结尾的字段。</p>
</li>
<li>
<p>匹配其他所有字符串类型字段。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>match_mapping_type</code> 允许你应用模板到特定类型的字段上，就像有标准动态映射规则检测的一样， (例如 <code>string</code> 或 <code>long</code>)。</p>
</div>
<div class="paragraph">
<p><code>match</code> 参数只匹配字段名称， <code>path_match</code> 参数匹配字段在对象上的完整路径，所以 <code>address.*.name</code> 将匹配这样的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "address": {
        "city": {
            "name": "New York"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unmatch</code> 和 <code>path_unmatch</code>将被用于未被匹配的字段。</p>
</div>
<div class="paragraph">
<p>更多的配置选项见 {ref}/dynamic-mapping.html[动态映射文档] 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default-mapping">缺省映射</h3>
<div class="paragraph">
<p>通常，一个索引中的所有类型共享相同的字段和设置。  <code><em>default</em></code> 映射更加方便地指定通用设置，而不是每次创建新类型时都要重复设置。 <code><em>default</em></code> 映射是新类型的模板。在设置 <code><em>default</em></code> 映射之后创建的所有类型都将应用这些缺省的设置，除非类型在自己的映射中明确覆盖这些设置。</p>
</div>
<div class="paragraph">
<p>例如，我们可以使用 <code><em>default</em></code> 映射为所有的类型禁用 <code>_all</code> 字段，  而只在 <code>blog</code> 类型启用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index
{
    "mappings": {
        "_default_": {
            "_all": { "enabled":  false }
        },
        "blog": {
            "_all": { "enabled":  true  }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><em>default</em></code> 映射也是一个指定索引 <a href="#dynamic-templates">dynamic templates</a> 的好方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="reindex">重新索引你的数据</h3>
<div class="paragraph">
<p>尽管可以增加新的类型到索引中，或者增加新的字段到类型中，但是不能添加新的分析器或者对现有的字段做改动。
  如果你那么做的话，结果就是那些已经被索引的数据就不正确，
搜索也不能正常工作。</p>
</div>
<div class="paragraph">
<p>对现有数据的这类改变最简单的办法就是重新索引：用新的设置创建新的索引并把文档从旧的索引复制到新的索引。</p>
</div>
<div class="paragraph">
<p>字段 <code>_source</code> 的一个优点是在Elasticsearch中已经有整个文档。你不必从源数据中重建索引，而且那样通常比较慢。</p>
</div>
<div class="paragraph">
<p>为了有效的重新索引所有在旧的索引中的文档，用 <a href="#scroll"><em>scroll</em></a> 从旧的索引检索批量文档  ，
然后用 <a href="#bulk"><code>bulk</code> API</a> 把文档推送到新的索引中。</p>
</div>
<div class="paragraph">
<p>从Elasticsearch v2.3.0开始， {ref}/docs-reindex.html[Reindex API] 被引入。它能够对文档重建索引而不需要任何插件或外部工具。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">批量重新索引</div>
<div class="paragraph">
<p>同时并行运行多个重建索引任务，但是你显然不希望结果有重叠。正确的做法是按日期或者时间
这样的字段作为过滤条件把大的重建索引分成小的任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /old_index/_search?scroll=1m
{
    "query": {
        "range": {
            "date": {
                "gte":  "2014-01-01",
                "lt":   "2014-02-01"
            }
        }
    },
    "sort": ["_doc"],
    "size":  1000
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果旧的索引持续会有变化，你希望新的索引中也包括那些新加的文档。那就可以对新加的文档做重新索引，
但还是要用日期类字段过滤来匹配那些新加的文档。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="index-aliases">索引别名和零停机</h3>
<div class="paragraph">
<p>在前面提到的，重建索引的问题是必须更新应用中的索引名称。   索引别名就是用来解决这个问题的！</p>
</div>
<div class="paragraph">
<p>索引 <em>别名</em> 就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名  带给我们极大的灵活性，允许我们做下面这些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在运行的集群中可以无缝的从一个索引切换到另一个索引</p>
</li>
<li>
<p>给多个索引分组 (例如， <code>last_three_months</code>)</p>
</li>
<li>
<p>给索引的一个子集创建 <code>视图</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在后面我们会讨论更多关于别名的使用。现在，我们将解释怎样使用别名在零停机下从旧索引切换到新索引。</p>
</div>
<div class="paragraph">
<p>有两种方式管理别名： <code>_alias</code> 用于单个操作， <code>_aliases</code> 用于执行多个原子级操作。</p>
</div>
<div class="paragraph">
<p>在本章中，我们假设你的应用有一个叫 <code>my_index</code> 的索引。事实上， <code>my_index</code> 是一个指向当前真实索引的别名。真实索引包含一个版本号： <code>my_index_v1</code> ， <code>my_index_v2</code> 等等。</p>
</div>
<div class="paragraph">
<p>首先，创建索引 <code>my_index_v1</code> ，然后将别名
<code>my_index</code> 指向它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index_v1 <b class="conum">(1)</b>
PUT /my_index_v1/_alias/my_index <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>创建索引 <code>my_index_v1</code> 。</p>
</li>
<li>
<p>设置别名 <code>my_index</code> 指向 <code>my_index_v1</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>你可以检测这个别名指向哪一个索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /*/_alias/my_index</code></pre>
</div>
</div>
<div class="paragraph">
<p>或哪些别名指向这个索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">GET /my_index_v1/_alias/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>两者都会返回下面的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
    "my_index_v1" : {
        "aliases" : {
            "my_index" : { }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们决定修改索引中一个字段的映射。当然，我们不能修改现存的映射，所以我们必须重新索引数据。   首先, 我们用新映射创建索引 <code>my_index_v2</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index_v2
{
    "mappings": {
        "my_type": {
            "properties": {
                "tags": {
                    "type":   "string",
                    "index":  "not_analyzed"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们将数据从 <code>my_index_v1</code> 索引到 <code>my_index_v2</code> ，下面的过程在 <a href="#reindex">重新索引你的数据</a> 中已经描述过。一旦我们确定文档已经被正确地重索引了，我们就将别名指向新的索引。</p>
</div>
<div class="paragraph">
<p>一个别名可以指向多个索引，所以我们在添加别名到新索引的同时必须从旧的索引中删除它。这个操作需要原子化，这意味着我们需要使用 <code>_aliases</code> 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">POST /_aliases
{
    "actions": [
        { "remove": { "index": "my_index_v1", "alias": "my_index" }},
        { "add":    { "index": "my_index_v2", "alias": "my_index" }}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你的应用已经在零停机的情况下从旧索引迁移到新索引了。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>即使你认为现在的索引设计已经很完美了，在生产环境中，还是有可能需要做一些修改的。</p>
</div>
<div class="paragraph">
<p>做好准备：在你的应用中使用别名而不是索引名。然后你就可以在任何时候重建索引。别名的开销很小，应该广泛使用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="inside-a-shard">分片内部原理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <a href="#distributed-cluster">集群内的原理</a>, 我们介绍了 <em>分片</em>, 并将它 描述成最小的 <em>工作单元</em>。但是究竟什么 <em>是</em> 一个分片，它是如何工作的？
在这个章节，我们回答以下问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为什么搜索是 <em>近</em> 实时的？</p>
</li>
<li>
<p>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 <em>实时</em> 的?</p>
</li>
<li>
<p>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</p>
</li>
<li>
<p>为什么删除文档不会立刻释放空间？</p>
</li>
<li>
<p><code>refresh</code>, <code>flush</code>, 和 <code>optimize</code> API 都做了什么, 你什么情况下应该是用他们？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最简单的理解一个分片如何工作的方式是上一堂历史课。 我们将要审视提供一个带近实时搜索和分析的 分布式持久化数据存储需要解决的问题。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">内容警告</div>
<div class="paragraph">
<p>本章展示的这些信息仅供您兴趣阅读。为了使用 Elasticsearch 您并不需要理解和记忆所有的细节。 读这个章节是为了了解工作机制，并且为了将来您需要这些信息时，知道这些信息在哪里。但是不要被这些细节所累。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="making-text-searchable">使文本可被搜索</h3>
<div class="paragraph">
<p>必须解决的第一个挑战是如何使文本可被搜索。
传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
</div>
<div class="paragraph">
<p>最好的支持 <em>一个字段多个值</em> 需求的数据结构是我们在 <a href="#inverted-index">倒排索引</a> 章节中介绍过的 <em>倒排索引</em> 。
倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 <em>词项</em> ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Term  | Doc 1 | Doc 2 | Doc 3 | ...
------------------------------------
brown |   X   |       |  X    | ...
fox   |   X   |   X   |  X    | ...
quick |   X   |   X   |       | ...
the   |   X   |       |  X    | ...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>当讨论倒排索引时，我们会谈到 <em>文档</em> 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。
Elasticsearch 中的 <em>文档</em> 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中，
每个被索引的字段都有自己的倒排索引。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数，
在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许
Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 <a href="#relevance-intro">什么是相关性?</a> 中有描述。</p>
</div>
<div class="paragraph">
<p>为了能够实现预期功能，倒排索引需要知道集合中的 <em>所有</em> 文档，这是需要认识到的关键问题。</p>
</div>
<div class="paragraph">
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。
一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
</div>
<div class="sect3 pagebreak-before">
<h4 id="_不变性">不变性</h4>
<div class="paragraph">
<p>倒排索引被写入磁盘后是 <em>不可改变</em> 的:它永远不会修改。
不变性有重要的价值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</p>
</li>
<li>
<p>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</p>
</li>
<li>
<p>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</p>
</li>
<li>
<p>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档
可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-indices">动态更新索引</h3>
<div class="paragraph">
<p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？答案是: 用更多的索引。</p>
</div>
<div class="paragraph">
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到&#8212;&#8203;从最早的开始&#8212;&#8203;查询完后再对结果进行合并。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 <em>按段搜索</em> 的概念。
每一 <em>段</em> 本身都是一个倒排索引，
但 <em>索引</em> 在 Lucene 中除表示所有 <em>段</em> 的集合外， 还增加了 <em>提交点</em> 的概念 &#x2014; 一个列出了所有已知段的文件，就像在 <a href="#img-index-segments">一个 Lucene 索引包含一个提交点和三个段</a> 中描绘的那样。
如 <a href="#img-memory-buffer">一个在内存缓存中包含新文档的 Lucene 索引</a> 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 <a href="#img-post-commit">在一次提交后，一个新的段被添加到提交点而且缓存被清空。</a> 所示。</p>
</div>
<div id="img-index-segments" class="imageblock">
<div class="content">
<img src="images/elas_1101.png" alt="A Lucene index with a commit point and three segments">
</div>
<div class="title">Figure 16. 一个 Lucene 索引包含一个提交点和三个段</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">索引与分片的比较</div>
<div class="paragraph">
<p>被混淆的概念是，一个 <em>Lucene 索引</em> 我们在 Elasticsearch 称作 <em>分片</em> 。
一个 Elasticsearch <em>索引</em> 是分片的集合。
当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 <a href="#distributed-search">执行分布式检索</a>
提到的那样，合并每个分片的结果到一个全局的结果集。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>逐段搜索会以如下流程进行工作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新文档被收集到内存索引缓存， 见 <a href="#img-memory-buffer">一个在内存缓存中包含新文档的 Lucene 索引</a> 。</p>
</li>
<li>
<p>不时地, 缓存被 <em>提交</em> ：</p>
<div class="ulist">
<ul>
<li>
<p>一个新的段&#8212;&#8203;一个追加的倒排索引&#8212;&#8203;被写入磁盘。</p>
</li>
<li>
<p>一个新的包含新段名字的 <em>提交点</em> 被写入磁盘。</p>
</li>
<li>
<p>磁盘进行 <em>同步</em> &#x2014; 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</p>
</li>
</ul>
</div>
</li>
<li>
<p>新的段被开启，让它包含的文档可见以被搜索。</p>
</li>
<li>
<p>内存缓存被清空，等待接收新的文档。</p>
</li>
</ol>
</div>
<div id="img-memory-buffer" class="imageblock">
<div class="content">
<img src="images/elas_1102.png" alt="A Lucene index with new documents in the in-memory buffer, ready to commit">
</div>
<div class="title">Figure 17. 一个在内存缓存中包含新文档的 Lucene 索引</div>
</div>
<div id="img-post-commit" class="imageblock">
<div class="content">
<img src="images/elas_1103.png" alt="After a commit, a new segment is added to the index and the buffer is cleared">
</div>
<div class="title">Figure 18. 在一次提交后，一个新的段被添加到提交点而且缓存被清空。</div>
</div>
<div class="paragraph">
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。
这种方式可以用相对较低的成本将新文档添加到索引。</p>
</div>
<div class="sect3">
<h4 id="deletes-and-updates">删除和更新</h4>
<div class="paragraph">
<p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。
取而代之的是，每个提交点会包含一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。</p>
</div>
<div class="paragraph">
<p>当一个文档被 “删除” 时，它实际上只是在 <code>.del</code> 文件中被 <em>标记</em> 删除。一个被标记删除的文档仍然可以被查询匹配到，
但它会在最终结果被返回前从结果集中移除。</p>
</div>
<div class="paragraph">
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。
可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
</div>
<div class="paragraph">
<p>在 <a href="#merge-process">段合并</a> , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="near-real-time">近实时搜索</h3>
<div class="paragraph">
<p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
</div>
<div class="paragraph">
<p>磁盘在这里成为了瓶颈。提交（Commiting）一个新的段到磁盘需要一个
<a href="http://en.wikipedia.org/wiki/Fsync"><code>fsync</code></a> 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。
但是 <code>fsync</code> 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
</div>
<div class="paragraph">
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 <code>fsync</code> 要从整个过程中被移除。</p>
</div>
<div class="paragraph">
<p>在Elasticsearch和磁盘之间是文件系统缓存。 像之前描述的一样，
在内存索引缓冲区（ <a href="#img-pre-refresh">在内存缓冲区中包含了新文档的 Lucene 索引</a> ）中的文档会被写入到一个新的段中（ <a href="#img-post-refresh">缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</a> ）。
但是这里新段会被先写入到文件系统缓存&#8212;&#8203;这一步代价会比较低，稍后再被刷新到磁盘&#8212;&#8203;这一步代价比较高。不过只要文件已经在缓存中，
就可以像其它文件一样被打开和读取了。</p>
</div>
<div id="img-pre-refresh" class="imageblock">
<div class="content">
<img src="images/elas_1104.png" alt="A Lucene index with new documents in the in-memory buffer">
</div>
<div class="title">Figure 19. 在内存缓冲区中包含了新文档的 Lucene 索引</div>
</div>
<div class="paragraph">
<p>Lucene 允许新段被写入和打开&#8212;&#8203;使其包含的文档在未进行一次完整提交时便对搜索可见。
这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
</div>
<div id="img-post-refresh" class="imageblock">
<div class="content">
<img src="images/elas_1105.png" alt="The buffer contents have been written to a segment, which is searchable, but is not yet commited">
</div>
<div class="title">Figure 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</div>
</div>
<div class="sect3">
<h4 id="refresh-api">refresh API</h4>
<div class="paragraph">
<p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 <em>refresh</em> 。
默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 <em>近</em> 实时搜索:
文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
</div>
<div class="paragraph">
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 <code>refresh</code> API 执行一次手动刷新:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /_refresh <b class="conum">(1)</b>
POST /blogs/_refresh <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>刷新（Refresh）所有的索引。</p>
</li>
<li>
<p>只刷新（Refresh） <code>blogs</code> 索引。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，
手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。
相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索，
可以通过设置 <code>refresh_interval</code> ， 降低每个索引的刷新频率：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_logs
{
  "settings": {
    "refresh_interval": "30s" <b class="conum">(1)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>每30秒刷新 <code>my_logs</code> 索引。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>refresh_interval</code> 可以在既存索引上进行动态更新。
在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">PUT /my_logs/_settings
{ "refresh_interval": -1 } <b class="conum">(1)</b>

PUT /my_logs/_settings
{ "refresh_interval": "1s" } <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>关闭自动刷新。</p>
</li>
<li>
<p>每秒自动刷新。</p>
</li>
</ol>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<code>refresh_interval</code> 需要一个 <em>持续时间</em> 值， 例如 <code>1s</code> （1 秒） 或 <code>2m</code> （2 分钟）。
一个绝对值 <em>1</em> 表示的是 <em>1毫秒</em> --无疑会使你的集群陷入瘫痪。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="translog">持久化变更</h3>
<div class="paragraph">
<p>如果没有用 <code>fsync</code> 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
</div>
<div class="paragraph">
<p>在 <a href="#dynamic-indices">动态更新索引</a>，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
</div>
<div class="paragraph">
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
</div>
<div class="paragraph">
<p>Elasticsearch 增加了一个 <em>translog</em> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个文档被索引之后，就会被添加到内存缓冲区，<em>并且</em> 追加到了 translog ，正如 <a href="#img-xlog-pre-refresh">新的文档被添加到内存缓冲区并且被追加到了事务日志</a> 描述的一样。</p>
<div id="img-xlog-pre-refresh" class="imageblock">
<div class="content">
<img src="images/elas_1106.png" alt="New documents are added to the in-memory buffer and appended to the transaction log">
</div>
<div class="title">Figure 21. 新的文档被添加到内存缓冲区并且被追加到了事务日志</div>
</div>
</li>
<li>
<p>刷新（refresh）使分片处于 <a href="#img-xlog-post-refresh">刷新（refresh）完成后, 缓存被清空但是事务日志不会</a> 描述的状态，分片每秒被刷新（refresh）一次：</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 <code>fsync</code> 操作。</p>
</li>
<li>
<p>这个段被打开，使其可被搜索。</p>
</li>
<li>
<p>内存缓冲区被清空。</p>
</li>
</ul>
</div>
<div id="img-xlog-post-refresh" class="imageblock">
<div class="content">
<img src="images/elas_1107.png" alt="After a refresh, the buffer is cleared but the transaction log is not">
</div>
<div class="title">Figure 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会</div>
</div>
</div>
</div>
</li>
<li>
<p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 <a href="#img-xlog-pre-flush">事务日志不断积累文档</a> ）。</p>
<div id="img-xlog-pre-flush" class="imageblock">
<div class="content">
<img src="images/elas_1108.png" alt="The transaction log keeps accumulating documents">
</div>
<div class="title">Figure 23. 事务日志不断积累文档</div>
</div>
</li>
<li>
<p>每隔一段时间&#8212;&#8203;例如 translog 变得越来越大&#8212;&#8203;索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 <a href="#img-xlog-post-flush">在刷新（flush）之后，段被全量提交，并且事务日志被清空</a> ）：</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>所有在内存缓冲区的文档都被写入一个新的段。</p>
</li>
<li>
<p>缓冲区被清空。</p>
</li>
<li>
<p>一个提交点被写入硬盘。</p>
</li>
<li>
<p>文件系统缓存通过 <code>fsync</code> 被刷新（flush）。</p>
</li>
<li>
<p>老的 translog 被删除。</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候，
它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</p>
</div>
<div class="paragraph">
<p>translog 也被用来提供实时 CRUD 。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，
首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
</div>
<div id="img-xlog-post-flush" class="imageblock">
<div class="content">
<img src="images/elas_1109.png" alt="After a flush, the segments are fully commited and the transaction log is cleared">
</div>
<div class="title">Figure 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空</div>
</div>
<div class="sect3">
<h4 id="flush-api">flush API</h4>
<div class="paragraph">
<p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 <em>flush</em> 。
分片每30分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看
 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/index-modules-translog.html#_translog_settings"><code>translog</code> 文档</a> 来设置，它可以用来
 控制这些阈值：</p>
</div>
<div class="paragraph">
<p>{ref}/indices-flush.html[<code>flush</code> API] 可以被用来执行一个手工的刷新（flush）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /blogs/_flush <b class="conum">(1)</b>

POST /_flush?wait_for_ongoing <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>刷新（flush） <code>blogs</code> 索引。</p>
</li>
<li>
<p>刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>你很少需要自己手动执行一个的 <code>flush</code> 操作；通常情况下，自动刷新就足够了。</p>
</div>
<div class="paragraph">
<p>这就是说，在重启节点或关闭索引之前执行 <a href="#flush-api">flush</a> 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引，
它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
</div>
<div id="how-safe-is-the-translog" class="sidebarblock">
<div class="content">
<div class="title">Translog 有多安全?</div>
<div class="paragraph">
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全？</p>
</div>
<div class="paragraph">
<p>在文件被 fsync 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 fsync 刷新到硬盘，
或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终，
基本上，这意味着在整个请求被 fsync 到主分片和复制分片的translog之前，你的客户端不会得到一个 200 OK 响应。</p>
</div>
<div class="paragraph">
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是bulk导入，它在一次请求中平摊了大量文档的开销）。</p>
</div>
<div class="paragraph">
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。</p>
</div>
<div class="paragraph">
<p>这个行为可以通过设置 <code>durability</code> 参数为 <code>async</code> 来启用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">PUT /my_index/_settings
{
    "index.translog.durability": "async",
    "index.translog.sync_interval": "5s"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 <em>保证</em> 在发生crash时，丢失掉 <code>sync_interval</code> 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
</div>
<div class="paragraph">
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ <code>"index.translog.durability": "request"</code> ）来避免数据丢失。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="merge-process">段合并</h3>
<div class="paragraph">
<p>由于自动刷新流程每秒会创建一个新的段  ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。
每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
</div>
<div class="paragraph">
<p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
</div>
<div class="paragraph">
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
</div>
<div class="paragraph">
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 <a href="#img-merge">两个提交了的段和一个未提交的段正在被合并到一个更大的段</a> 中提到的一样工作：</p>
</div>
<div class="paragraph">
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
</div>
<div class="paragraph">
<p>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
</div>
<div id="img-merge" class="imageblock">
<div class="content">
<img src="images/elas_1110.png" alt="Two commited segments and one uncommited segment in the process of being merged into a bigger segment">
</div>
<div class="title">Figure 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段</div>
</div>
<div class="paragraph">
<p>3、 <a href="#img-post-merge">一旦合并结束，老的段被删除</a> 说明合并完成时的活动：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>新的段被刷新（flush）到了磁盘。
   ** 写入一个包含新段且排除旧的和较小的段的新提交点。</p>
</li>
<li>
<p>新的段被打开用来搜索。</p>
</li>
<li>
<p>老的段被删除。</p>
</li>
</ul>
</div>
<div id="img-post-merge" class="imageblock">
<div class="content">
<img src="images/elas_1111.png" alt="一旦合并结束，老的段被删除">
</div>
<div class="title">Figure 26. 一旦合并结束，老的段被删除</div>
</div>
</div>
</div>
<div class="paragraph">
<p>合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然
有足够的资源很好地执行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
查看 <a href="#segments-and-merging">[segments-and-merging]</a> 来为你的实例获取关于合并调整的建议。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="optimize-api">optimize API</h4>
<div class="paragraph">
<p><code>optimize</code> API大可看做是 <em>强制合并</em> API。它会将一个分片强制合并到 <code>max_num_segments</code> 参数指定大小的段数目。
这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<code>optimize</code> API <em>不应该</em> 被用在一个动态索引————一个正在被活跃更新的索引。后台合并流程已经可以很好地完成工作。
optimizing 会阻碍这个进程。不要干扰它！
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在特定情况下，使用 <code>optimize</code> API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。
老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
</div>
<div class="paragraph">
<p>在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">POST /logstash-2014-10/_optimize?max_num_segments=1 <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>合并索引中的每个分片为一个单独的段</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，使用 <code>optimize</code> API 触发段合并的操作一点也不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。
如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 <a href="#migrate-indices">[migrate-indices]</a>）把索引移到一个安全的节点，再执行。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-05-17 22:26:24 CST
</div>
</div>
</body>
</html>